<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MIT6.S081操作系统实验——Xv6 and Unix utilities</title>
    <url>/article/9396/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本实验需要编写一些用户程序，执行系统调用来达成目标。作为第一个实验，本次实验内容比较简单，主要内容是展示用户如何调用操作系统的接口，即<em>system call</em>，在下一个实验中将详细展示系统调用的工作流程。</p>
<p>本次实验的学习目标是：</p>
<ul>
<li><p>学习并理解用户使用shell执行命令时的具体过程</p>
<ul>
<li>命令的参数如何被进程使用</li>
</ul>
</li>
<li><p>对Unix的进程间通信方式之一<em>pipe</em>有基础了解</p>
<ul>
<li>为什么用户进程要使用OS提供的IPC进行通信？</li>
</ul>
</li>
<li><p>了解Unix中的file description，理解Unix中”一切皆文件“的理念</p>
</li>
<li><p>初步了解make项目以及Makefile</p>
</li>
</ul>
<p>实验原文：<a href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
<span id="more"></span>

<h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><p>进入工作文件夹下，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout util <span class="comment">#切换到util分支，对应本实验</span></span><br><span class="line">git clean -xfd <span class="comment">#清除无关文件（未追踪的、忽略的文件和文件夹）</span></span><br><span class="line">git checkout -b solveutil <span class="comment">#新建一个solveutil分支，来记录自己的编程过程</span></span><br></pre></td></tr></table></figure>

<h1 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (easy)</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>写一个用户程序sleep，执行系统调用来实现休眠。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>观察<code>user/grep.c</code>等文件来学习命令行参数如何传入程序。</li>
<li>将<code>sleep.c</code>添加进<code>Makefile</code>中的UPROGS。（添加完后点击<code>Makefile</code>右上角图标重新加载make项目才能将<code>sleep.c</code>加入索引）</li>
<li>在用户没有给出sleep的参数时打印错误信息。</li>
<li>使用<code>atoi</code>函数将命令行参数由字符串转为整形。</li>
<li>确保<code>main</code>函数调用了<code>exit</code>函数来退出程序。</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sleep.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep ticks\n&quot;</span>);<span class="comment">//stderr的文件描述符的值为2</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(ticks);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong(easy)"></a>pingpong(easy)</h1><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>写一个用户程序pingpong，实现两个进程间的数据传递。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><ul>
<li>使用<code>pipe</code>建立管道。</li>
</ul>
<blockquote>
<p>关于管道的理解可以看这篇博文：<a href="https://blog.csdn.net/qq_35433716/article/details/86171936">Linux系统编程pipe()</a></p>
</blockquote>
<ul>
<li>使用<code>fork</code>创建子进程。</li>
<li>使用<code>read</code>和<code>write</code>对管道进行读和写。</li>
<li>使用<code>getpid</code>获取当前进程的pid。</li>
</ul>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];<span class="comment">//parent-&gt;child</span></span><br><span class="line">    <span class="type">int</span> p2[<span class="number">2</span>];<span class="comment">//child-&gt;parent</span></span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//child</span></span><br><span class="line">        <span class="type">char</span> buffer[] = &#123;<span class="string">&#x27;y&#x27;</span>&#125;;</span><br><span class="line">        read(p1[<span class="number">0</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        write(p2[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    <span class="type">char</span> buffer[] = &#123;<span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line">    write(p1[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    read(p2[<span class="number">0</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="primes-moderate-x2F-hard"><a href="#primes-moderate-x2F-hard" class="headerlink" title="primes(moderate&#x2F;hard)"></a>primes(moderate&#x2F;hard)</h1><h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h2><p>使用管道写一个并发版本的素数筛来找出2~35中的素数。</p>
<blockquote>
<p>相关链接：<a href="https://swtch.com/~rsc/thread/">Bell Labs and CSP Threads (swtch.com)</a></p>
</blockquote>
<p>概念图：</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/1gfBPmyOSnMvtCl.gif" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><ul>
<li><p>请牢记这个题目的要求是<strong>通过多线程来加速素数筛</strong>，在编写程序时要检查自己的程序是否满足并发，<strong>一定不要在父进程写入所有数字后子进程才开始处理！</strong>即使这样也能通过测试。</p>
</li>
<li><p>请小心关闭进程不需要的文件描述符，否则程序将在第一个进程达到 35 之前耗尽xv6的资源。（<strong>及时关闭管道非常重要！！！</strong>）</p>
</li>
<li><p>当一个进程读取完所有数字后，应该等到所有他的子进程终止才能终止，从而避免产生僵尸进程。（善用<code>ctrl+p</code>）</p>
</li>
<li><p>当一个管道的写端被关闭时，对读端进行<code>read</code>会返回0。</p>
</li>
<li><p>写入所有数字后<strong>再写入一个0来表示写入完毕</strong>，否则子进程无法知道父进程是否写入完毕。采取这种做法是因为执行了<code>fork</code>后父进程才关闭管道写端，子进程并不能感应到管道写端已经关闭了。</p>
</li>
</ul>
<h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//primes.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    pipe(p1);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">        write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> n, prime, p2[<span class="number">2</span>];</span><br><span class="line">        pipe(p2);</span><br><span class="line">        read(p1[<span class="number">0</span>], &amp;prime, <span class="keyword">sizeof</span>(prime));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        <span class="keyword">if</span> (read(p1[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)) &amp;&amp; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//子进程会复制一遍父进程的两个管道，其中父进程用来与祖父进程交流的管道应该被关闭</span></span><br><span class="line">                close(p1[<span class="number">0</span>]);</span><br><span class="line">                close(p1[<span class="number">1</span>]);</span><br><span class="line">                p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">                p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n % prime != <span class="number">0</span>)</span><br><span class="line">                    write(p2[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(p1[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)) &amp;&amp; n);</span><br><span class="line">            write(p2[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭占用的管道</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find(moderate)"></a>find(moderate)</h1><h2 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h2><p>写一个简单版本的UNIX find程序，<code>ls path filename</code>为寻找目录path下所有文件名为filename的文件并输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ <span class="built_in">mkdir</span> a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><ul>
<li>查看<code>user/ls.c</code>中的代码来学习如何读取文件夹。</li>
<li>使用递归来实现遍历所有子目录。</li>
<li>不要递归进入<code>.</code>（即当前目录）和<code>..</code>（即父目录）</li>
<li>请使用<code>strcmp</code>函数而非<code>==</code></li>
</ul>
<h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取path中的文件名*/</span></span><br><span class="line"><span class="type">char</span> *</span><br><span class="line"><span class="title function_">filename</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *p = path;</span><br><span class="line">    <span class="keyword">while</span> (*p)</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; p != path)</span><br><span class="line">        p--;</span><br><span class="line">    <span class="keyword">return</span> p == path ? p : ++p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path)</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename(path), target) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                find(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find path filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target = argv[<span class="number">2</span>];</span><br><span class="line">    find(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs(moderate)"></a>xargs(moderate)</h1><h2 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h2><p>写一个简单版本的UNIX xargs程序，从STDIN逐行读取，将每一行作为参数执行命令。比如<code>echo hello too | xargs echo bye</code>，要输出<code>bye hello too</code>，等价于<code>echo bye hello too</code>，建议看原文理解。</p>
<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><ul>
<li><p>使用<code>gets</code>函数来读取STDIN。</p>
</li>
<li><p>使用<code>fork</code>和<code>exec</code>函数来执行子进程。</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xargs.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>], *xargs[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        xargs[i - <span class="number">1</span>] = argv[i];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x = argc - <span class="number">1</span>;</span><br><span class="line">        gets(buf, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        xargs[x++] = buf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> *p = buf; *p; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                *p = <span class="number">0</span>;</span><br><span class="line">                xargs[x++] = p + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                *p = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(argv[<span class="number">1</span>], xargs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><p>输入<code>make grade</code>或<code>python ./grade-lab-util</code>来评测整个实验。</p>
<p>若想单独评测一个题目比如sleep可以使用<code>python ./grade-lab-util sleep</code>。</p>
<p>评测整个实验前别忘了在Xv6根目录创建一个名为<code>time.txt</code>的文件，在里面输入一个整数表明自己在这个实验上花了多少个小时。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>MIT Lab</tag>
        <tag>Xv6</tag>
        <tag>pipe</tag>
        <tag>IPC</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081操作系统实验——page tables</title>
    <url>/article/41624/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>Before you start coding, read Chapter 3 of the <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">xv6 book</a>, and related files:</p>
<ul>
<li><code>kern/memlayout.h</code>, which captures the layout of memory.</li>
<li><code>kern/vm.c</code>, which contains most virtual memory (VM) code.</li>
<li><code>kernel/kalloc.c</code>, which contains code for allocating and freeing physical memory.</li>
</ul>
<p>It may also help to consult the <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V privileged architecture manual</a>.</p>
</blockquote>
<p>本次实验的学习目标是：</p>
<ul>
<li>学习页式虚拟储存管理的作用以及实现原理</li>
<li>了解内核和用户进程的虚拟地址布局以及RISC-V的物理地址布局</li>
<li>学习Sv39 RISC-V的地址映射原理</li>
</ul>
<p>实验原文：<a href="https://pdos.csail.mit.edu/6.828/2021/labs/pgtbl.html">Lab: page tables (mit.edu)</a></p>
<span id="more"></span>

<h1 id="虚拟地址的意义"><a href="#虚拟地址的意义" class="headerlink" title="虚拟地址的意义"></a>虚拟地址的意义</h1><h2 id="将"><a href="#将" class="headerlink" title="将"></a>将</h2>]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>MIT Lab</tag>
        <tag>Xv6</tag>
        <tag>virtual memory</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081操作系统实验——system calls</title>
    <url>/article/64950/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>Before you start coding, read Chapter 2 of the <a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev1.pdf">xv6 book</a>, and Sections 4.3 and 4.4 of Chapter 4, and related source files:</p>
<ul>
<li>The user-space code for systems calls is in <code>user/user.h</code> and <code>user/usys.pl</code>.</li>
<li>The kernel-space code is <code>kernel/syscall.h</code>, <code>kernel/syscall.c</code>.</li>
<li>The process-related code is <code>kernel/proc.h</code> and <code>kernel/proc.c</code>.</li>
</ul>
</blockquote>
<p>本次实验的主要内容是学习系统调用的工作流程，实现两个简单的系统调用。</p>
<p>实验原文：<a href="https://pdos.csail.mit.edu/6.828/2021/labs/syscall.html">Lab: System calls (mit.edu)</a></p>
<span id="more"></span>

<h1 id="系统调用基本流程"><a href="#系统调用基本流程" class="headerlink" title="系统调用基本流程"></a>系统调用基本流程</h1><h2 id="用户空间"><a href="#用户空间" class="headerlink" title="用户空间"></a>用户空间</h2><p>根据实验说明的提示，用户进程执行系统调用时相关的代码在<code>user/user.h</code>中声明，在 <code>user/usys.pl</code>中定义。</p>
<p>首先可以看到<code>user/user.h</code>中有很多预设的系统调用。在Clion中，部分系统调用的左边会显示转到定义的双向箭头，但实际上转向的内容是内核空间对应的代码而非用户空间对应的代码。</p>
<p>实际的定义写在 <code>user/usys.pl</code>中，在make时perl脚本会被编译为汇编文件<code>usys.S</code>。</p>
<p>打开编译后的<code>usys.S</code>可以看到以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># generated by usys.pl - do not edit</span><br><span class="line">#include &quot;kernel/syscall.h&quot;</span><br><span class="line">.global fork</span><br><span class="line">fork:</span><br><span class="line"> li a7, SYS_fork</span><br><span class="line"> ecall</span><br><span class="line"> ret</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>首先执行<code>#include &quot;kernel/syscall.h&quot;</code>导入系统调用的编号，然后接下来是各个系统调用的定义，每一个系统调用只有三行指令。</p>
<p>以fork举例，<code>.global fork</code>表示fork是一个全局函数，<code>li a7, SYS_fork</code>表示将SYS_fork的值加载到trapframe的a7中（li &#x3D; load immediate），trapframe是在进程陷入内核态时保存寄存器状态的结构。接下来执行<code>ecall</code>陷入内核态，在内核完成系统调用后执行<code>ret</code>结束系统调用。</p>
<h2 id="内核空间"><a href="#内核空间" class="headerlink" title="内核空间"></a>内核空间</h2><p>根据实验说明的提示，内核空间关于系统调用的代码写在<code>kernel/syscall.h</code>和<code>kernel/syscall.c</code>中。</p>
<p>在用户空间执行完<code>ecall</code>后，CPU陷入内核态，本质上是将当前运行的进程从执行系统调用的用户进程切换到内核进程，这个转换过程将在实验四trap中详细学习。</p>
<p>切换完成后，执行<code>syscall()</code>处理系统调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = p-&gt;trapframe-&gt;a7;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">      p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            p-&gt;pid, p-&gt;name, num);</span><br><span class="line">    p-&gt;trapframe-&gt;a0 = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从trapframe的a7中获取系统调用编号，然后执行相应的系统调用，并将返回值写入trapframe的a0中，至此完成系统调用，CPU从内核态转回用户态，转换回去的具体过程同样在实验四中学习。</p>
<p>其中syscalls是一个<strong>函数指针数组</strong>，使用了一种特殊的初始化方式<del>（我也是第一次见到）</del>，用来自定义初始化数组的成员，数组的长度取决于成员下标的最大值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">uint64</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">[SYS_fork]    sys_fork,</span><br><span class="line">[SYS_exit]    sys_exit,</span><br><span class="line">[SYS_wait]    sys_wait,</span><br><span class="line">[SYS_pipe]    sys_pipe,</span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>syscalls首先与<code>[]</code>结合，所以它是一个数组；接着与<code>*</code>结合，所以这个数组的成员是指针；指针的类型是<code>uint64 (void)</code>，即参数类型为<code>void</code>，返回值类型为<code>uint64</code>的函数。</p>
<blockquote>
<p>如果无法理解这个数组的类型定义可以参考我的另一篇博文：<a href="https://foliet.com/article/11681/">浅析数组与指针</a></p>
</blockquote>
<p>最后<code>static</code>修饰syscalls表示它是一个静态变量，只在本文件内可以被访问，类似java中的<code>private</code>。<code>static</code>在汇编中的体现就是被修饰的变量在汇编中没有<code>.global</code>修饰。</p>
<blockquote>
<p>关于<code>static</code>可以参考这篇博文：<a href="https://zhuanlan.zhihu.com/p/515804741">C语言static修饰符作用 汇编层面验证</a></p>
</blockquote>
<h1 id="System-call-tracing-moderate"><a href="#System-call-tracing-moderate" class="headerlink" title="System call tracing (moderate)"></a>System call tracing (moderate)</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>了解完系统调用基本流程可以进入正题了，这个实验的目标是实现系统调用trace，参数为一个整数，该整数的第n个二进制位为1时表示追踪编号为n的系统调用<strong>（包括trace本身）</strong>。例如，为了跟踪 fork和exit 系统调用，程序调用 <code>trace(1 &lt;&lt; SYS_fork + 1 &lt;&lt; SYS_exit)</code>。</p>
<p>在执行被追踪的系统调用后，打印进程ID、系统调用的名称和返回值。</p>
<h2 id="关键过程"><a href="#关键过程" class="headerlink" title="关键过程"></a>关键过程</h2><h3 id="修改进程结构体"><a href="#修改进程结构体" class="headerlink" title="修改进程结构体"></a>修改进程结构体</h3><p>为了能够记录进程想要追踪的系统调用，需要在PCB中添加一个成员来达成目的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># kernel/proc.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">lock</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// p-&gt;lock must be held when using these:</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> <span class="title">state</span>;</span>        <span class="comment">// Process state</span></span><br><span class="line">......</span><br><span class="line">  <span class="comment">// wait_lock must be held when using this:</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span>         <span class="comment">// Parent process</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// these are private to the process, so p-&gt;lock need not be held.</span></span><br><span class="line">  <span class="type">int</span> trace;</span><br><span class="line">  uint64 kstack;               <span class="comment">// Virtual address of kernel stack</span></span><br><span class="line">......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>新增的成员trace是进程的私有成员，所以在对它进行操作的时候不需要先获取自旋锁。</p>
<p>关于操作一个成员时是否需要先获取自旋锁我的理解是，只有在进程处于<em>RUNNING</em>状态才会被访问的成员是<strong>不需要</strong>先获取自旋锁的，因为<strong>一个进程在任意时刻最多只可能运行在一个CPU上</strong>，那么这些成员不可能同时被两个CPU修改或者访问，自然就没有互斥问题。</p>
<h3 id="实现sys-trace"><a href="#实现sys-trace" class="headerlink" title="实现sys_trace"></a>实现sys_trace</h3><p><code>sys_trace</code>的逻辑非常简单，只要获取参数并把参数赋值给PCB的trace就完成了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_trace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    argint(<span class="number">0</span>, &amp;myproc()-&gt;trace);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完成任务是次要的，学习知识才是首要任务。</strong>下面来分析一下内核如何获取用户进程执行系统调用时传递的参数。</p>
<p><code>argint</code>、<code>argaddr</code>、<code>argstr</code>实际上都是简单地调用了<code>argraw</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> uint64</span><br><span class="line"><span class="title function_">argraw</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a0;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a1;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a2;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a3;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a4;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    <span class="keyword">return</span> p-&gt;trapframe-&gt;a5;</span><br><span class="line">  &#125;</span><br><span class="line">  panic(<span class="string">&quot;argraw&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看<code>argraw</code>的源码可以看到xv6的系统调用最多可以传递六个参数，使用trapframe的a0~a5进行传递。</p>
<p>值得一提的是，在risc-v指令集架构中，调用普通函数时将使用a0~a7共八个寄存器进行参数传递，也就是传递八个参数，当参数超过八个时多出来的参数使用进程栈进行传递，类似x86。当函数返回时，使用寄存器a0和a1来传递返回值。</p>
<h3 id="修改syscall"><a href="#修改syscall" class="headerlink" title="修改syscall"></a>修改syscall</h3><p>为了输出系统调用的名称，首先我们要先定义一个数组储存各个系统调用的名字，仿照syscalls的定义方式定义一个数组syscalls_name如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span>* syscalls_name[] = &#123;</span><br><span class="line">[SYS_fork]    = <span class="string">&quot;fork&quot;</span>,</span><br><span class="line">[SYS_exit]    = <span class="string">&quot;exit&quot;</span>,</span><br><span class="line">[SYS_wait]    = <span class="string">&quot;wait&quot;</span>,</span><br><span class="line">[SYS_pipe]    = <span class="string">&quot;pipe&quot;</span>,</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相比于syscalls，这里在定义每个成员时多加了一个等于号，实际上这样才是标准的写法，syscalls的定义方法是GNU的一种扩展语法，允许省略等于号，可以不加等于号，但是Clion会给出警告。</p>
<p>接下来在内核执行完具体的系统调用后，检查PCB的trace中与该系统调用编号相对应的二进制位是否被置为1，如果是，输出相应信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">p-&gt;trapframe-&gt;a0 = syscalls[num]();</span><br><span class="line"><span class="keyword">if</span>(p-&gt;trace&amp;(<span class="number">1</span>&lt;&lt;num))&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d: syscall %s -&gt; %d\n&quot;</span>, p-&gt;pid, syscalls_name[num], p-&gt;trapframe-&gt;a0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此系统调用trace实现完成。</p>
<h1 id="Sysinfo-moderate"><a href="#Sysinfo-moderate" class="headerlink" title="Sysinfo(moderate)"></a>Sysinfo(moderate)</h1><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>这个任务预设了一个有两个成员的结构体sysinfo，其中nproc表示未使用的进程数，也就是还可以创建的进程数，freemem表示操作系统空闲物理内存的字节数。任务的目标是实现系统调用sysinfo，接受一个sysinfo的指针，并填充它的字段。</p>
<h2 id="关键过程-1"><a href="#关键过程-1" class="headerlink" title="关键过程"></a>关键过程</h2><h3 id="统计未使用的进程数"><a href="#统计未使用的进程数" class="headerlink" title="统计未使用的进程数"></a>统计未使用的进程数</h3><p>非常简单，只需要遍历一遍内核的进程数组，统计state为<em>UNUSED</em>的进程数量即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">proc_count</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span>;</span></span><br><span class="line">    uint64 count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(p = proc; p &lt; &amp;proc[NPROC]; p++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;state!=UNUSED)count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计空闲物理内存的字节数"><a href="#统计空闲物理内存的字节数" class="headerlink" title="统计空闲物理内存的字节数"></a>统计空闲物理内存的字节数</h3><p>观察<code>kalloc.c</code>中的代码可以发现，kmem是用来管理物理内存的结构，物理内存被分成了若干个大小为<em>PGSIZE</em>（其值为4096）bytes的单位，通常称之为物理页。kmem中的freelist是记录空闲物理页地址的链表，freelist的长度即为空闲物理页的个数，所以遍历链表计算长度，再将长度乘以<em>PGSIZE</em>即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">kcount</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">run</span> *<span class="title">r</span>;</span></span><br><span class="line">    uint64 count = <span class="number">0</span>;</span><br><span class="line">    acquire(&amp;kmem.lock);</span><br><span class="line">    r = kmem.freelist;</span><br><span class="line">    <span class="keyword">while</span>(r)&#123;</span><br><span class="line">        r=r-&gt;next;</span><br><span class="line">        count+=PGSIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    release(&amp;kmem.lock);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是内存使用情况在不断变化，统计时必须先获取kmem的互斥锁。</p>
<h3 id="实现sys-sysinfo"><a href="#实现sys-sysinfo" class="headerlink" title="实现sys_sysinfo"></a>实现sys_sysinfo</h3><p>用户进程传递了一个地址作为参数，由于虚拟内存的存在，内核和用户进程的地址空间是分离的，不能在内核态下直接向用户进程传递的地址写入数据，而是要先使用用户进程的页表来找到该虚拟地址对应的物理地址，然后才能将sysinfo的值写入。</p>
<p>仿照系统调用fstat，调用copyout来完成从内核空间到用户空间的数据传递。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">uint64</span><br><span class="line"><span class="title function_">sys_sysinfo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">p</span> =</span> myproc();</span><br><span class="line">    uint64 addr;</span><br><span class="line">    argaddr(<span class="number">0</span>,&amp;addr);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sysinfo</span> <span class="title">info</span>;</span></span><br><span class="line">    info.nproc=proc_count();</span><br><span class="line">    info.freemem=kcount();</span><br><span class="line">    <span class="keyword">if</span>(copyout(p-&gt;pagetable, addr, (<span class="type">char</span> *)&amp;info, <span class="keyword">sizeof</span>(info)) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此系统调用sysinfo实现完成。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>MIT Lab</tag>
        <tag>Xv6</tag>
        <tag>system call</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081操作系统实验——环境搭建与项目简介</title>
    <url>/article/1631/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做过各种语言的项目，对网站架构和职业要求有一个基础认知后，我认为要在卷翻天的职场立足，在了解并能使用前沿技术的同时还得打好计算机基础，所以痛下决心重拾大二摸鱼过去的OS实验。</p>
<p>2018年及以前MIT6.828是MIT的本科生OS课程，2019开始这门课被拆成了6.S081和6.828，分别成为本科生和研究生的OS课程。6.S081的实验由原来的5个拆成了10个，总体难度降低，更加易于基础并不牢固的学生学习。</p>
<p>我将记录2021年课程的实验全过程，下文是运行环境以及<strong>调试环境</strong>搭建的记录，着重记录<strong>如何使用CLion进行远程开发以及远程调试</strong>，这在网上很难找到相应资料。</p>
<p><del>非常佩服能使用原始gdb进行调试的人，已经是一个离不开ide的快速跳转，自动补全，集成调试的废物了。</del></p>
<p>课程链接：<a href="https://pdos.csail.mit.edu/6.828/2021/">6.S081 &#x2F; Fall 2021 (mit.edu)</a></p>
<span id="more"></span>

<h1 id="什么是Xv6和RISC-V？"><a href="#什么是Xv6和RISC-V？" class="headerlink" title="什么是Xv6和RISC-V？"></a>什么是Xv6和RISC-V？</h1><p>本课程用来教学和演示的操作系统是基于RISC-V指令集架构的Xv6操作系统，但不是一开始就如此。</p>
<p>本课程的前身6.828最开始使用的是Unix V6（简称V6，基于PDP-11硬件体系和旧式C语言开发）作为教学用OS，而在实验环节，学生们主要是在x86架构的CPU上实现一个称为Jos的“外核”架构(exokernel)的操作系统。</p>
<p>很多学生怀疑使用V6这样一个30多年前的，使用旧式C语言（比K&amp;R C还要旧）开发的，并且在过时的PDP-11硬件上运行的系统是否合适。而且学生们还要苦于同时学习PDP-11和Intel x86两种不同架构的底层差别。于是在2006年夏天，课程的老师们决定以V6为基础，使用ANSI C写一个新的在Intel x86多处理器计算机上的系统，也就是Xv6，来代替V6。</p>
<p>从2019年开始，新课程6.S081使用精简指令集RISC-V替代了原有的复杂指令集x86来开发Xv6。</p>
<p>总的来说，RISC-V和x86都是CPU的指令集架构，Xv6和Windows、Linux、MacOS等都是运用这些指令集架构来管理硬件的操作系统。</p>
<h1 id="安装Linux虚拟机以及必要工具下载"><a href="#安装Linux虚拟机以及必要工具下载" class="headerlink" title="安装Linux虚拟机以及必要工具下载"></a>安装Linux虚拟机以及必要工具下载</h1><p>课程的文档里有各个平台的安装教程，本文以VMware Workstation Pro 16中安装Ubuntu20.04.4 Server作为基础环境。</p>
<blockquote>
<p>环境配置指引：<a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081 &#x2F; Fall 2021 (mit.edu)</a></p>
</blockquote>
<p>安装虚拟机可以在百度上找到很多教程，这里不再赘述，仅放出下载链接</p>
<ul>
<li><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">下载 VMware Workstation Pro | CN</a></li>
<li><a href="https://cn.ubuntu.com/download/server/step1">获取Ubuntu服务器版 | Ubuntu</a></li>
</ul>
<p>我下载的Ubuntu是Server版，只有命令行没有桌面，更喜爱桌面版可以自行下载。</p>
<p>安装完成并启动虚拟机后输入以下命令下载必要工具，主要是c&#x2F;c++编译工具集，riscv64架构的gnu工具集，qemu虚拟机，git，适用于riscv64架构的gdb。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<p>直接下载可能会过于缓慢，如果太慢了请先替换apt源为国内源（<strong>请尽量用较新的源</strong>）。这里使用的是阿里源和清华源，网上教程有很多，以下是我使用的源，用它替换掉*&#x2F;etc&#x2F;apt&#x2F;source.list*中的内容后输入<code>apt-get update</code>就行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加阿里源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment">#添加清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="下载Xv6的git仓库"><a href="#下载Xv6的git仓库" class="headerlink" title="下载Xv6的git仓库"></a>下载Xv6的git仓库</h1><p>在用户文件夹下输入以下命令下载课程的Xv6源码，注意<strong>不要下载Xv6的官方源码而是下载课程改动过的源码</strong>，对改动内容感兴趣的话可以使用<code>git log</code>查看改动内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br></pre></td></tr></table></figure>

<blockquote>
<p>下载速度可能很缓慢，可以直接从我的git仓库fork一份或直接clone。</p>
<p>仓库链接：<a href="https://github.com/foliet/MIT-6.s081">foliet&#x2F;MIT-6.s081 (github.com)</a></p>
</blockquote>
<p>我仓库my+实验名的分支是我自己完成后代码，ricsv分支是Xv6的源码，其他十个分支是对应lab的分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:Foliet/MIT-6.s081.git <span class="comment">#ssh</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Foliet/MIT-6.s081.git <span class="comment">#https</span></span><br></pre></td></tr></table></figure>

<p>先进入文件夹内，然后输入以下两条命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout util</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p>看到如下输出即为启动成功，一切顺利，否则按照课程原文说明逐个工具检查是否下载成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c</span><br><span class="line">...  </span><br><span class="line">riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o</span><br><span class="line">riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm</span><br><span class="line">riscv64-unknown-elf-objdump -t user/_zombie | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &gt; user/zombie.sym</span><br><span class="line">mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie </span><br><span class="line">nmeta 46 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000</span><br><span class="line">balloc: first 591 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h1 id="配置Ubuntu的ssh服务器"><a href="#配置Ubuntu的ssh服务器" class="headerlink" title="配置Ubuntu的ssh服务器"></a>配置Ubuntu的ssh服务器</h1><p>输入<code>sudo su</code>进入root用户模式，然后输入<code>passwd</code>为root用户设置一个密码。</p>
<p>输入<code>ls /etc/ssh</code>命令查看是否有<em>sshd_config</em>这个文件，如果没有则输入<code>apt-get install openssh-server</code>下载。</p>
<p>将<code>sshd_config</code>中的PermitRootLogin的#号去掉，并将值改为yes。</p>
<p>输入<code>service ssh restart</code>重启ssh服务。（<strong>如果没设置开机自动启动，那么每次开机都要重启ssh服务</strong>）</p>
<p>完成后在物理机上打开一个shell，输入以下命令尝试连接虚拟机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@&#123;你的虚拟机ip&#125;</span><br><span class="line">ssh root@192.168.126.128 <span class="comment"># 比如这样</span></span><br></pre></td></tr></table></figure>

<p>如果不成功请转向百度找问题，搜索<strong>“以root用户连接ssh服务器”</strong>应该能找到很多教程。</p>
<h1 id="在CLion上连接虚拟机"><a href="#在CLion上连接虚拟机" class="headerlink" title="在CLion上连接虚拟机"></a>在CLion上连接虚拟机</h1><p>CLion是jetbrains公司面向c&#x2F;c++的ide，<strong>通过学生优惠可以免费获取全家桶的一年通行证，并且在校期间可以无限续，只需要有edu后缀的邮箱就行了</strong>。</p>
<blockquote>
<p>Clion下载地址：<a href="https://www.jetbrains.com/zh-cn/clion/">CLion：JetBrains 出品的 C 和 C++ 跨平台 IDE</a></p>
<p>学生优惠链接：<a href="https://www.jetbrains.com/community/education/#students">Free Educational Licenses - Community Support (jetbrains.com)</a></p>
</blockquote>
<h2 id="配置工具链"><a href="#配置工具链" class="headerlink" title="配置工具链"></a>配置工具链</h2><p>新建一个项目，打开<strong>设置</strong>，选择<strong>构建、执行、部署</strong>，选择<strong>工具链</strong>，点上方加号➕添加一个远程主机，添加一个ssh凭据并手动输入gdb-multiarch的路径来替代默认gdb（原始gdb不能识别riscv的指令集）。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329105815490.png" alt="image-20220329105815490"></p>
<p>我这里是下了cmake，不下cmake也没关系，只需要管<strong>凭据</strong>和<strong>调试器</strong>。</p>
<h2 id="配置部署服务器"><a href="#配置部署服务器" class="headerlink" title="配置部署服务器"></a>配置部署服务器</h2><p>点击上方<strong>工具</strong>，选择<strong>部署</strong>，点击<strong>配置</strong>，填好映射路径。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329130436272.png" alt="image-20220329130436272"></p>
<p>然后依次点<strong>工具</strong>、<strong>部署</strong>、<strong>浏览远程主机</strong>，就可以管理虚拟机的文件了，在这里可以很方便的直接管理虚拟机文件。</p>
<p>删除项目内初始的文件（如果有的话），右键项目文件夹，点击部署，然后下载虚拟机里的文件。</p>
<h2 id="配置Makefile项目"><a href="#配置Makefile项目" class="headerlink" title="配置Makefile项目"></a>配置Makefile项目</h2><p>打开设置，将构建目标设置为<em>qemu-gdb</em>。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/d3PMj8gnxAlXT6u.png" alt="image-20220402152641258"></p>
<p><strong>如果设置里显示未检测到<em>Makefile</em>项目就删掉项目文件夹里的*.idea*文件夹，然后重新打开项目。</strong>之前的设置会被初始化，需要重新设置一下。</p>
<p>设置完了之后打开<em>Makefile</em>文件，点右上角按钮重新加载项目。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/FXeTWYk2zhjrHGS.png" alt="image-20220402152934792"></p>
<p>此时索引就建立完毕了，可以自动补全和<code>ctrl+B</code>来快速跳转了。</p>
<h2 id="添加调试配置"><a href="#添加调试配置" class="headerlink" title="添加调试配置"></a>添加调试配置</h2><p>在右上角打开<strong>运行&#x2F;调试配置</strong>，添加一个<strong>远程调试</strong>的配置。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329124021990.png" alt="image-20220329124021990"></p>
<p>课程内的gdb服务器默认使用<em>25000</em>端口。</p>
<p>执行<code>make</code>后会对内核程序和和每个用户程序各生成一个符号文件，内核的符号文件就叫<em>kernel</em>，用户程序的符号文件为_{程序名}，例如ls的符号文件为<em>_ls</em>。</p>
<h2 id="设置-gdbinit"><a href="#设置-gdbinit" class="headerlink" title="设置.gdbinit"></a>设置.gdbinit</h2><p>在*&#x2F;root<em>文件夹下创建一个名为</em>.gdbinit*的文件</p>
<p>向里面填入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> confirm off</span><br><span class="line"><span class="built_in">set</span> architecture riscv:rv64</span><br><span class="line">file kernel/kernel</span><br><span class="line">add-symbol-file user/_ls</span><br><span class="line"><span class="built_in">set</span> disassemble-next-line auto</span><br><span class="line"><span class="built_in">set</span> riscv use-compressed-breakpoints <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>这里是调试<em>ls</em>，如果要调试自己写的程序，比如说<em>myproc</em>，就添加一行<code>add-symbol-file user/_myproc</code>。</p>
<h2 id="启动调试服务器"><a href="#启动调试服务器" class="headerlink" title="启动调试服务器"></a>启动调试服务器</h2><p>在虚拟机的Xv6文件夹下输入<code>make qemu-gdb</code>来启动gdb服务器，如遇到错误可以尝试<code>make clean</code>来清除之前make生成的文件，shell输出以下内容即为开启成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br></pre></td></tr></table></figure>

<p>如果显示<em>25000</em>端口已被占用或者文件<em>fs.img</em>被占用，应该是上一次运行没有正确退出，请自行百度查找如何根据占用端口或者文件获取pid，然后kill掉，这里建议使用lsof。</p>
<ul>
<li><code>apt-get install lsof</code>安装lsof。</li>
<li><code>lsof fs.img</code>和<code>lsof -i:25000</code>查询进程。</li>
</ul>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>点击CLion右上角调试按钮开始调试ls程序，下方会显示连接成功，然后回到shell会发现可以输入命令了，此时我输入<code>ls grep</code>，成功触发断点。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/dE2UWb5O3a6RSvo.png" alt="image-20220329131621170"></p>
<h1 id="Xv6和CLion相关"><a href="#Xv6和CLion相关" class="headerlink" title="Xv6和CLion相关"></a>Xv6和CLion相关</h1><ul>
<li>Xv6没有实现ps程序，要列出当前进程可以在Xv6的终端里中输入<code>ctrl+p</code>，关闭Xv6先按<code>ctrl+a</code>再按<code>x</code>。</li>
<li>调试Xv6时发生读取空指针，缓冲区溢出等错误时CLion不会报错，但是会导致调试异常，当系统中断，跳转到<em>spinlock.c</em>等文件内时需要格外注意。</li>
<li>在CLion内可以用<code>ctrl+alt+h</code>来查看一个函数被哪些函数调用了。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>MIT Lab</tag>
        <tag>Clion</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.S081操作系统实验——操作系统是如何在qemu虚拟机中启动的？</title>
    <url>/article/42403/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为了更好的理解基于RISC-V体系的Xv6操作系统是如何在qemu中启动的，我将详细地梳理从执行<code>make qemu</code>命令开始到Xv6的shell启动为止的具体流程。</p>
<span id="more"></span>

<h1 id="执行make-qemu后发生了什么？"><a href="#执行make-qemu后发生了什么？" class="headerlink" title="执行make qemu后发生了什么？"></a>执行make qemu后发生了什么？</h1><blockquote>
<p>如果不了解Makefile的语法可以先看一下这篇博文：<a href="https://blog.csdn.net/qlexcel/article/details/105903157">Makefile的语法</a></p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">qemu: $K/kernel fs.img</span></span><br><span class="line">	<span class="variable">$(QEMU)</span> <span class="variable">$(QEMUOPTS)</span></span><br></pre></td></tr></table></figure>

<p>执行<code>make qemu</code>后会先检查是否生成了最新的kernel和fs.img，如果是则使用qemu启动kernel，通过终端可以看到qemu的参数指定了Xv6的虚拟机环境为128MB内存和3个处理器核心。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,<span class="built_in">id</span>=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br></pre></td></tr></table></figure>

<p>再跳转到kernel的生成目标中可以看到，在所有文件编译完成后，使用kernel.ld脚本控制链接过程，然后反编译产生用来调试的符号文件，而我们只需要关注链接过程。</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">$K/kernel: <span class="variable">$(OBJS)</span> <span class="variable">$(OBJS_KCSAN)</span> $K/kernel.ld $U/initcode</span></span><br><span class="line">	<span class="variable">$(LD)</span> <span class="variable">$(LDFLAGS)</span> -T $K/kernel.ld -o $K/kernel <span class="variable">$(OBJS)</span> <span class="variable">$(OBJS_KCSAN)</span></span><br><span class="line">	<span class="variable">$(OBJDUMP)</span> -S $K/kernel &gt; $K/kernel.asm</span><br><span class="line">	<span class="variable">$(OBJDUMP)</span> -t $K/kernel | sed &#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d&#x27; &gt; $K/kernel.sym</span><br></pre></td></tr></table></figure>

<blockquote>
<p>链接脚本的语法可以参考这篇博文：<a href="https://www.cnblogs.com/zjutzz/p/4006114.html">ld 脚本浅析-LD手册粗糙翻译</a></p>
<p>Xv6使用和基于RISC-V架构的linux相同的可执行文件格式ELF，关于ELF可以参考这篇博客：<a href="https://blog.csdn.net/GrayOnDream/article/details/124564129">ELF文件格式简介</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OUTPUT_ARCH( &quot;riscv&quot; )</span><br><span class="line">ENTRY( _entry )</span><br><span class="line"></span><br><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">  /*</span><br><span class="line">   * ensure that entry.S / _entry is at 0x80000000,</span><br><span class="line">   * where qemu&#x27;s -kernel jumps.</span><br><span class="line">   */</span><br><span class="line">  . = 0x80000000; # 将定位器置于0x80000000，这个地址的意义之后会提到。</span><br><span class="line"></span><br><span class="line">  .text : &#123; # 将`.text`节的起点置于定位器所在地址也就是0x80000000</span><br><span class="line">    *(.text .text.*) # 合并所有文件的.text节和任意以.text.开头的节的内容，并置于定位器现在的位置。</span><br><span class="line">    . = ALIGN(0x1000); # 将定位器以0x1000（即4096，一个内存页的大小）为base进行地址对齐。</span><br><span class="line">    _trampoline = .; # 将定位器现在的位置赋值给符号_trampoline，是用户进程陷入内核态的入口。</span><br><span class="line">    *(trampsec) # 合并所有文件的trampsec节（实际上只定义在trampoline.S中）并置于定位器现在的位置。</span><br><span class="line">    . = ALIGN(0x1000); # 同上</span><br><span class="line">    ASSERT(. - _trampoline == 0x1000, &quot;error: trampoline larger than one page&quot;); # 确保trampoline不大于一个内存页。</span><br><span class="line">    PROVIDE(etext = .); # 定义一个新符号etext，值为定位器现在的位置。</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">  PROVIDE(end = .); # 定义一个新符号end，值为定位器现在的位置。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接脚本中比较关键的部分是代码节<code>.text</code>，其他节即<code>.data</code>、<code>.rodata</code>、<code>.bss</code>为数据节，只是简单的合并了所有文件的数据节。</p>
<p>链接脚本最上方的两条脚本命令<code>OUTPUT_ARCH</code>、<code>ENTRY</code><strong>实际上没有任何作用并且可以删掉</strong>，把<code>ENTRY</code>的参数换成其他函数名都不影响系统启动，因为<code>ENTRY</code>的作用是指定ELF header中entry的值，并不能影响<code>.text</code>节内函数顺序。而由于之前配置的GNU套件本身是用来适配RISC-V架构的，所以<code>OUTPUT_ARCH</code>默认为riscv。</p>
<p>由于在链接命令中<code>entry.o</code>排在可重定向文件的第一位，所以<code>entry.o</code>的字段在链接的合并过程中排在最前面，在执行<code>make qemu</code>时可以看到链接命令如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv64-linux-gnu-ld -z max-page-size=4096 -T kernel/kernel.ld -o kernel/kernel kernel/entry.o kernel/kalloc.o kernel/string.o kernel/main.o kernel/vm.o kernel/proc.o kernel/swtch.o kernel/trampoline.o kernel/trap.o kernel/syscall.o kernel/sysproc.o kernel/bio.o kernel/fs.o kernel/log.o kernel/sleeplock.o kernel/file.o kernel/pipe.o kernel/exec.o kernel/sysfile.o kernel/kernelvec.o kernel/plic.o kernel/virtio_disk.o kernel/start.o kernel/console.o kernel/printf.o kernel/uart.o kernel/spinlock.o</span><br></pre></td></tr></table></figure>

<p>之所以要确保<code>_entry</code>在地址0x80000000，是因为这是Xv6启动的入口函数。但即使删除了对entry的指定，编译后打开<code>kernel.asm</code>依然可以看到函数<code>_entry</code>排在最前面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel/kernel:     file format elf64-littleriscv</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">0000000080000000 &lt;_entry&gt;:</span><br><span class="line">    80000000:	00009117          	auipc	sp,0x9</span><br><span class="line">    80000004:	92813103          	ld	sp,-1752(sp) # 80008928 &lt;_GLOBAL_OFFSET_TABLE_+0x8&gt;</span><br><span class="line">    80000008:	6505                	lui	a0,0x1</span><br><span class="line">    8000000a:	f14025f3          	csrr	a1,mhartid</span><br><span class="line">    8000000e:	0585                	addi	a1,a1,1</span><br><span class="line">    80000010:	02b50533          	mul	a0,a0,a1</span><br><span class="line">    80000014:	912a                	add	sp,sp,a0</span><br><span class="line">    80000016:	0f3050ef          	jal	ra,80005908 &lt;start&gt;</span><br></pre></td></tr></table></figure>

<p>顺带提一句，合并后的SECTION被称为SEGMENT，链接命令中的<code>-z max-page-size=4096</code>指定了一个SEGMENT的最大长度，因为在Xv6载入新进程的时候会为每一个可以被载入内存的SEGMENT分配一个内存页，所以一个SEGMENT的长度不可以超过一个内存页的大小，这在之后会提到。</p>
<h1 id="Xv6的入口代码是如何开始执行的？"><a href="#Xv6的入口代码是如何开始执行的？" class="headerlink" title="Xv6的入口代码是如何开始执行的？"></a>Xv6的入口代码是如何开始执行的？</h1><p>首先我们打开<code>memlayout.h</code>来看一下Xv6的物理地址布局。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Physical memory layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// qemu -machine virt is set up like this,</span></span><br><span class="line"><span class="comment">// based on qemu&#x27;s hw/riscv/virt.c:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 00001000 -- boot ROM, provided by qemu</span></span><br><span class="line"><span class="comment">// 02000000 -- CLINT</span></span><br><span class="line"><span class="comment">// 0C000000 -- PLIC</span></span><br><span class="line"><span class="comment">// 10000000 -- uart0 </span></span><br><span class="line"><span class="comment">// 10001000 -- virtio disk </span></span><br><span class="line"><span class="comment">// 80000000 -- boot ROM jumps here in machine mode</span></span><br><span class="line"><span class="comment">//             -kernel loads the kernel here</span></span><br><span class="line"><span class="comment">// unused RAM after 80000000.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the kernel uses physical memory thus:</span></span><br><span class="line"><span class="comment">// 80000000 -- entry.S, then kernel text and data</span></span><br></pre></td></tr></table></figure>

<p>从这里可以看到，qemu在地址0x1000上提供了boot ROM，qemu模拟计算机启动，并在这个地方3个CPU同时以特权等级Machine开始执行启动程序，启动程序会使CPU跳转到0x80000000，也就是函数<code>_entry</code>的位置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_entry:</span><br><span class="line">	# set up a stack for C.</span><br><span class="line">        # stack0 is declared in start.c,</span><br><span class="line">        # with a 4096-byte stack per CPU.</span><br><span class="line">        # sp = stack0 + (hartid * 4096)</span><br><span class="line">        la sp, stack0 # load address，将数组stack0的首地址存入寄存器sp。</span><br><span class="line">        li a0, 1024*4 # load immediate，将立即数4096存入寄存器a0。</span><br><span class="line">	csrr a1, mhartid # CSR read，读取寄存器mhartid并存入a1。</span><br><span class="line">        addi a1, a1, 1 # a1++</span><br><span class="line">        mul a0, a0, a1 # a0 *= a1</span><br><span class="line">        add sp, sp, a0 # sp += a0</span><br><span class="line">	# jump to start() in start.c</span><br><span class="line">        call start</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果对RISC-V的指令集感兴趣可以看一看官方文档：<a href="https://pdos.csail.mit.edu/6.828/2021/reference.html">6.S081 &#x2F; Fall 2021 (mit.edu)</a></p>
</blockquote>
<p>la和li指令都是来自GNU工具集的伪指令，不属于RISC-V的指令集，在汇编阶段会被翻译为多条其他指令。</p>
<p>csrr是特权相关的指令，用来从CSR中读取数据，CSR即<em>Control and Status Register</em>，控制与状态寄存器，属于CPU自带的一类寄存器。</p>
<h1 id="Xv6如何进行初始化？"><a href="#Xv6如何进行初始化？" class="headerlink" title="Xv6如何进行初始化？"></a>Xv6如何进行初始化？</h1><p>执行完<code>_entry</code>后，每个CPU都分配到了一个栈，并跳转至函数<code>start</code>，如果<code>start</code>返回（操作系统启动失败），则进入死循环函数<code>spin</code>。</p>
<p>定义在<code>start.c</code>中的<code>start</code>包含一些包装起来的汇编指令，总结一下就是：</p>
<ul>
<li>声明在执行<code>mret</code>后特权等级切换到Supervisor并跳转至函数<code>main</code>。</li>
<li>禁用Supervisor模式下的地址转换和保护，即直接操作物理内存。</li>
<li>将所有中断和异常处理设定在Supervisor模式下。</li>
<li>允许Supervisor模式访问所有物理内存。</li>
<li>初始化时钟中断。</li>
<li>将CPU的id存入寄存器tp。</li>
<li>执行<code>mret</code>指令，切换特权等级，跳转至函数<code>main</code>。</li>
</ul>
<p>接着转到<code>main.c</code>中的<code>main</code>。总结一下就是CPU0以外其他CPU先忙等待直到CPU0初始化完操作系统的各个组件并开启地址转换和中断处理，然后其他CPU开启地址转换和中断处理，每个CPU在完成初始化后开始调度用户进程。</p>
<h1 id="Xv6如何载入用户进程？"><a href="#Xv6如何载入用户进程？" class="headerlink" title="Xv6如何载入用户进程？"></a>Xv6如何载入用户进程？</h1><p>在CPU0初始化操作系统的过程中有一步<code>userinit</code>，跳转到<code>proc.c</code>中的<code>userinit</code>可以看到第一个用户进程初始化的过程。</p>
<p>首先执行<code>allocproc</code>获取一个新进程，通过<code>uvminit</code>将initcode即<code>exec(&quot;/init&quot;)</code>编译后的二进制码存入进程的虚拟地址0x0，并将0存入程序计数器，最后将进程的状态设置为<em>RUNNING</em>。</p>
<p>在CPU开始调度进程后，第一个用户进程即initcode将会获得CPU时间并执行<code>exec(&quot;/init&quot;)</code>。</p>
<h1 id="Xv6如何启动shell？"><a href="#Xv6如何启动shell？" class="headerlink" title="Xv6如何启动shell？"></a>Xv6如何启动shell？</h1><p>首先转到<code>init.c</code>的开头，<code>mknod</code>的全称是<em>make node</em>，作用是将一个外部设备映射为一个设备文件。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(open(<span class="string">&quot;console&quot;</span>, O_RDWR) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    mknod(<span class="string">&quot;console&quot;</span>, CONSOLE, <span class="number">0</span>);</span><br><span class="line">    open(<span class="string">&quot;console&quot;</span>, O_RDWR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类UNIX操作系统的文件系统有”一切皆文件“的设计理念，操作系统为文件夹、设备、网络接口、管道、链接提供同样的接口进行I&#x2F;O操作。</p>
<p>类似对系统调用进行编号，Xv6在<code>file.h</code>里对各种外部设备进行了编号，其中<em>CONSOLE</em>代表键盘、鼠标、显示屏，为了能够读写这些外部设备，<code>init</code>进程需要使用<code>mknod</code>来创建一个设备文件，第一个参数指定产生的设备文件的名字，第二个参数指定外部设备编号，它的最后一个参数用来选择读取设备的哪个单元。启动Xv6后执行ls可以看到最后面有一个<code>console</code>文件，文件类型是3，在<code>file.h</code>里可以看到表示DEVICE。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">.              1 1 1024</span><br><span class="line">..             1 1 1024</span><br><span class="line">README         2 2 2226</span><br><span class="line"><span class="built_in">cat</span>            2 3 24296</span><br><span class="line">......</span><br><span class="line">console        3 20 0</span><br></pre></td></tr></table></figure>

<p>执行完<code>mknod</code>后执行<code>open</code>来获取CONSOLE的fd即<em>file description</em>，由于这是第一个打开的文件，所以fd为0，接着执行两次<code>dup(0)</code>表示重复创建两个新fd，依次为1和2，和原来的fd指向同一个文件。也就是说，0、1、2所代表的STDIN、STDOUT、STDERR实际上是同一个文件，代表同一个设备CONSOLE。</p>
<p>接下来fork出一个新进程并载入可执行文件sh，最后进入一段循环，如果是shell退出了，那么重启shell；如果是其他进程退出了，那么说明这是一个孤儿进程，什么都不做。</p>
<p>至此整个Xv6操作系统启动完毕。</p>
]]></content>
      <categories>
        <category>操作系统</category>
        <category>MIT6.S081</category>
      </categories>
      <tags>
        <tag>MIT Lab</tag>
        <tag>Xv6</tag>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>从Internet设计原则中汲取经验</title>
    <url>/article/10652/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从Internet设计原则中汲取经验"><a href="#从Internet设计原则中汲取经验" class="headerlink" title="从Internet设计原则中汲取经验"></a>从Internet设计原则中汲取经验</h1><p>要深入理解软件工程的概念，就应该从那些经典的工程中学习，寻找共性。 从优秀工程的设计原则中思考，反思自己的项目工作中的设计方式， 回忆那些让开发变得很混乱的问题。<br>从前人总结出的设计原则中和自己的工作对比，找出哪些是自己可以改进的，慢慢学习如何进行工程设计。</p>
<span id="more"></span>

<p>Internet最重要的设计原则包括以下十点</p>
<h2 id="保证工作"><a href="#保证工作" class="headerlink" title="保证工作"></a>保证工作</h2><blockquote>
<p>直到多个原型系统成功地与对方相互通信，方可完成设计或者确定标准。设计者常常首先写出一个1000页的标准，并获得批准，过后才发现存在严重的缺陷，根本无法工作。然后他们再编写一个1.1版本的标准。这不是正确的工作方式。</p>
</blockquote>
<p>在建立标准前应该先测试一下可行性，有的时候我会认为自己的想法非常容易实现，甚至简单到没必要测试，等到了实际开发的时候，特别是在实现那些我认为是细枝末节的地方时，发现这个地方的逻辑有问题，根本不可能实现。</p>
<p>比如说我在设计数据库的表关系时，有order和user两个实体，每个user有很多order。依据数据库设计三大范式，我在order的表里添加了user_id来建立映射关系，这听起来非常正确，所以我在最初以此作为标准进行开发。</p>
<p>根据这个想法我实现了后端的功能，但是当我回到前端开发时，意识到我在前端需要显示每个订单对应的用户的名字。<br>在不改变后端代码的情况下，想要实现这个功能必须向后端发送大量的包来进行查询每个user_id对应的user，再把用户名给读取出来，这显然是效率低下的！</p>
<p>于是我只能选择去重构后端（我前面举的例子是实际问题的简化，实际情况还要再复杂一点），而如果一开始先好好思考可行性并推敲好使用流程就可以避免类似的麻烦。</p>
<p>上述问题在<strong>保证工作</strong>这个原则下的启示是，应该先尝试着将一条order的信息展示出来，再将标准确定下来。即使自己觉得逻辑非常清晰，也应该好好的从头开始捋一捋流程，避免忽略不切实际的设计。</p>
<p>就好像是高中的导数题，拿到题一看迅速的对应上了解题模型，觉得这道题非常简单，等到实际做起来发现好像和不是同一个类型的题。它很像曾经做过的某题，但是解题方法并不一样，而到发现这个问题时只能推倒重做。</p>
<p><strong>这个原则不是要否定那些逻辑并不足够严谨的假设，而是警告设计者不要想当然地认为某些东西应该是对的</strong></p>
<h2 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h2><blockquote>
<p>有疑问时应该使用最简单的解决方案。William of Occam在14世纪就提出了这条原则(称为奥卡姆的剃刀)。换成现代术语就是:决斗特性。如果一项特性并非绝对不要，那么就放弃该特性。尤其是，通过组合其他的特性也能够获得同样效果的时候。</p>
</blockquote>
<h2 id="明确选择"><a href="#明确选择" class="headerlink" title="明确选择"></a>明确选择</h2><blockquote>
<p>如果有几种方法可以完成同样的事情，则选择其中一种方法。用两种或者多种方法来做同样的事情简直是自找麻烦。通常标准会有多个选项、多种模式或多个参数，因为多个实力强大的参与方坚持认为他们的方法是最好的。设计者应该坚决抵制这种倾向，学会说“不”。</p>
</blockquote>
<h2 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h2><blockquote>
<p>这条原则直接导致了协议栈的思想，每一层的协议完全独立于所有其他的协议。按照这种方法，如果实际环境中要求改变一个模块或者一层，则其他模块或层都不会受到影响。</p>
</blockquote>
<p>编写代码时一定得注重<strong>”高内聚，低耦合“</strong>，这是有效提升可维护性的手段，试想以下情景：</p>
<ul>
<li><p>你正在编写一个函数，已经写了一百多行，当你逻辑不够清晰时想再重新梳理一遍这个函数，发现自己一时难以重新理顺逻辑。</p>
</li>
<li><p>你需要在两个不同的地方做同样的事情，你为了方便直接复制粘贴再稍微修改了一下，一切运行正常。过了几天你改了前一个位置的代码并调试至可以正常运行。之后，你在使用过程中发现后一个位置出了问题，你看了看发现原来是后面那里忘了改。</p>
</li>
<li><p>程序有bug，出问题的函数有一百多行，很难确定在哪个位置。</p>
<p>以上问题都在于过多功能杂糅到一个模块里，而没有把任务切块，分成若干个零件，单个模块承担了过多责任，即内聚性弱。或者一个地方的修改导致很多其他地方也要修改，即耦合性强。</p>
<p>如果要写归并排序，把二分和合并分开一定有助于编写；如果要写一个网页，若内容较多，将布局分成header、footer、aside、main，每一块单独做一个文件来处理会是不错的选择；使用vue开发，分割组件时，尽量用props暴露最低限度的接口而不是使用refs直接操作子组件（在必须耦合的情况下尽量数据耦合而不是控制耦合）；多个模块共享的数据应该是常量；一个模块只暴露必要的接口，其他部分应该对外部隐藏，而留出的接口应该在一开始就规划好以保证不到万不得已的情况不修改。</p>
<p>以上一些增强内聚性，降低耦合性的方法。</p>
<p><a href="https://baike.baidu.com/item/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/5227009?fr=aladdin">高内聚低耦合_百度百科</a></p>
</li>
</ul>
<h2 id="期望异构性"><a href="#期望异构性" class="headerlink" title="期望异构性"></a>期望异构性</h2><blockquote>
<p>在任何一个大型的网络中，可能存在不同类型的硬件、传输设施和应用程序。为了处理它们，网络的设计必须简单、通用和灵活。</p>
</blockquote>
<h2 id="避免静态选项和参数"><a href="#避免静态选项和参数" class="headerlink" title="避免静态选项和参数"></a>避免静态选项和参数</h2><blockquote>
<p>如果不可避免要使用参数的话（比如最大数据包长度)，那么，最好的办法是让发送方和接收方协商一个值，而不是定义固定的参数值。</p>
</blockquote>
<p>比如说设计网页时一个页面展示多少条信息可以由用户选择；设计mc的一个物品时它的掉落率可以由配置文件调整</p>
<h2 id="寻找好的而不是完美的设计"><a href="#寻找好的而不是完美的设计" class="headerlink" title="寻找好的而不是完美的设计"></a>寻找好的而不是完美的设计</h2><blockquote>
<p>通常设计者有一个好的设计，但是它不能够处理一些怪异的特殊情况。设计者不应该乱改设计，而是坚持这个好的设计，将围绕着特殊情况而展开的工作负担转移到那些强烈需求的人身上。</p>
</blockquote>
<h2 id="严格发送，宽容接收"><a href="#严格发送，宽容接收" class="headerlink" title="严格发送，宽容接收"></a>严格发送，宽容接收</h2><blockquote>
<p>换句话说，只发送那些严格符合标准的数据包，但是，容许接收那些不完全符合标准的数据包，并且试图对它们进行处理。</p>
</blockquote>
<p>分工设计时，不要想着别人的数据包是严格符合你的思维的，考虑好各种可能的null问题</p>
<h2 id="考虑可扩展性"><a href="#考虑可扩展性" class="headerlink" title="考虑可扩展性"></a>考虑可扩展性</h2><blockquote>
<p>如果系统需要有效地处理上百万台主机和几十亿用户，那么，没有一种中心数据库是可以容忍的,同时必须将负载尽可能均匀地分布到所有可用的资源上。</p>
</blockquote>
<h2 id="考虑性能和成本"><a href="#考虑性能和成本" class="headerlink" title="考虑性能和成本"></a>考虑性能和成本</h2><blockquote>
<p>如果一个网络的性能很差，或者成本很高，那么没有人会使用它。</p>
</blockquote>
]]></content>
      <categories>
        <category>规范与标准</category>
      </categories>
      <tags>
        <tag>Internet</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-思维构造专题</title>
    <url>/article/37296/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>专题名为Violence Art，但实际上是考验选手思维的能力，题目的数据范围都不大，但是需要思考如何枚举所有情况，需要构造能力。<br><a href="https://codeforces.com/group/5FquYr3Pbe/contest/289144">测验传送门</a></p>
<span id="more"></span>
<h1 id="题目选集"><a href="#题目选集" class="headerlink" title="题目选集"></a>题目选集</h1><h2 id="A-Travelling-Salesman-and-Special-Numbers"><a href="#A-Travelling-Salesman-and-Special-Numbers" class="headerlink" title="A. Travelling Salesman and Special Numbers"></a>A. Travelling Salesman and Special Numbers</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer $x$ and reduce it to the number of bits set to $1$ in the binary representation of $x$. For example for number $13$ it’s true that $13_{10} &#x3D; 1101_2$, so it has 3 bits set and $13$ will be reduced to $3$ in one operation.<br>He calls a number special if the minimum number of operations to reduce it to $1$ is $k$.<br>He wants to find out how many special numbers exist which are not greater than $n$. Please help the Travelling Salesman, as he is about to reach his destination!<br>Since the answer can be large, output it modulo $10^9 + 7$.<br><strong>Input</strong><br>The first line contains integer $n (1 ≤ n &lt; 2^{1000})$.<br>The second line contains integer $k (0 ≤ k ≤ 1000)$.<br>Note that $n$ is given in its binary representation without any leading zeros.<br><strong>Output</strong><br>Output a single integer — the number of special numbers not greater than $n$, modulo $10^9 + 7$.</p>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111111011</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">169</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong><br>In the first sample, the three special numbers are $3$, $5$ and $6$. They get reduced to $2$ in one operation (since there are two set bits in each of $3$, $5$ and $6$) and then to $1$ in one more operation (since there is only one set bit in $2$).</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一个1000位以内的二进制数，假设有a个1，将这个数变为十进制的a再转成二进制视为一次操作，求不大于n且能<strong>恰好</strong>通过k次操作将其变为1的数有多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>2的1000次方约为10的300次方，直接暴力穷举每个数显然是不现实的，但注意到<strong>任何一个有a个位为1的数都可以视为等价的</strong>，毕竟经过一次操作后都变成了a，那么先列举好有1000以内个1的每种情况需要多少次操作，再根据组合数知识算一下不大于n的数中，有不同个1位的数各有多少就可以了。<br>但发现求有x个1且小于n的数也并不能直接组合数公式得出，则从最高位开始往下遍历，计算从第i位开始比n小的所有数中，有各个数量的1各有多少个，即以下部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=s.<span class="built_in">size</span>()-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[num+j]+=<span class="built_in">c</span>(s.<span class="built_in">size</span>()-i,j);<span class="comment">//这一位前面有num个1，这一位后面有j个1</span></span><br><span class="line">                a[num+j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比1小那只能是那一位为0，而且但不可能比0小，所以直接跳过为0的位<br>还有一个特殊值’1’，1只需要0次运算，所以当k为1的时候答案要减一，当k为0的时候答案不为0而是1</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">1005</span>],a[<span class="number">1005</span>],cmb[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//ans[i]表示有i个1的数需要多少次操作，a[i]表示小与n的数中有a[i]个数有i个1，cmb用来记录组合数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">c</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> m)</span><span class="comment">//采用记忆化dp的方法算组合数，避免多余运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cmb[n][m])<span class="keyword">return</span> cmb[n][m];</span><br><span class="line">    <span class="type">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(!m||n==m)res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> res = <span class="built_in">c</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)%mod+<span class="built_in">c</span>(n<span class="number">-1</span>,m)%mod;</span><br><span class="line">    cmb[n][m]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[n])<span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="type">int</span> m=n,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)sum++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[m]=<span class="built_in">f</span>(sum)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    string s;</span><br><span class="line">	<span class="type">int</span> k,num=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=s.<span class="built_in">size</span>()-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[num+j]+=<span class="built_in">c</span>(s.<span class="built_in">size</span>()-i,j);</span><br><span class="line">                a[num+j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[num]++;</span><br><span class="line">    <span class="type">int</span> res = k==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(i)==k)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=a[i];</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)res--;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Full-Binary-Tree-Queries"><a href="#F-Full-Binary-Tree-Queries" class="headerlink" title="F. Full Binary Tree Queries"></a>F. Full Binary Tree Queries</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 4 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You have a full binary tree having infinite levels.<br>Each node has an initial value. If a node has value $x$, then its left child has value $2·x$ and its right child has value $2·x + 1$.<br>The value of the root is 1.<br>You need to answer $Q$ queries.<br>There are 3 types of queries:<br>Cyclically shift the <strong>values</strong> of all nodes on the same level as node with value $X$ by $K$ units. (The values&#x2F;nodes of any other level are not affected).<br>Cyclically shift the <strong>nodes</strong> on the same level as node with value $X$ by $K$ units. (The subtrees of these nodes will move along with them).<br>Print the value of every node encountered on the simple path from the node with value $X$ to the root.<br>Positive $K$ implies right cyclic shift and negative $K$ implies left cyclic shift.<br>It is guaranteed that atleast one type 3 query is present.<br><strong>Input</strong><br>The first line contains a single integer $Q\ (1 ≤ Q ≤ 10^5)$.<br>Then $Q$ queries follow, one per line:</p>
<ul>
<li>Queries of type 1 and 2 have the following format: $T$ $X$ $K$ $(1 ≤ T ≤ 2; 1 ≤ X ≤ 10^{18}; 0 ≤ |K| ≤ 10^{18})$, where $T$ is type of the query.</li>
<li>Queries of type 3 have the following format: $3$ $X$ $(1 ≤ X ≤ 10^{18})$.<br><strong>Output</strong><br>For each query of type 3, print the values of all nodes encountered in descending order.</li>
</ul>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 12</span><br><span class="line">1 2 1</span><br><span class="line">3 12</span><br><span class="line">2 4 -1</span><br><span class="line">3 8</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12 6 3 1</span><br><span class="line">12 6 2 1</span><br><span class="line">8 4 2 1</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 14</span><br><span class="line">1 5 -3</span><br><span class="line">3 14</span><br><span class="line">1 3 1</span><br><span class="line">3 14</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14 7 3 1</span><br><span class="line">14 6 3 1</span><br><span class="line">14 6 2 1</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong><br>Following are the images of the first 4 levels of the tree in the first test case:<br>Original:<img src="https://espresso.codeforces.com/9bc9b00a4be0824f3ab3a052f7c55ae5ad4a1bae.png" alt="Alt"><br>After query 1 2 1:<img src="https://espresso.codeforces.com/c525b5916b994c6630d3d0abf7d051fdd9421292.png" alt="Alt"><br>After query 2 4 -1:<img src="https://espresso.codeforces.com/5954801d203dc3c0c4bf27e9bf96656f9946792b.png" alt="Alt"></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一棵无限大的<strong>满二叉树</strong>，有Q个询问（操作），1是让x所在的那一排的值右移k格，2是让x所在那一排的节点右移k格（就是带着子树一起移动），3是从x出发向根节点遍历，输出遇到的所有节点的值</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用一个数组记录每一排目前右移了多少格，第0排是根节点1，第1排是2、3。</p>
<ul>
<li>当遇到操作2，记录好x的那一排右移了k格后（注意<strong>取模</strong>，后面也是，第$i$排对$2^i$取模），从下一排直到62排（最大只需要考虑$2^{62}$，写到63次方会溢出的），每往下一排位移的格数为上一排的两倍。画个图可以看出，如果节点2向右位移一格，节点4需要移动两格，节点8需要移动四格，得出规律。</li>
<li>当遇到操作1，相对于操作2，不需要考虑之后的节点的位移，只需记录x那一排的位移即可</li>
<li>当遇到操作3，根据每一行记录过的移动的格子数，逐行求解<br>好像即使是对long long进行32位以上的左移操作也不行，没时间想怎么处理，直接记录2的前62次幂的值来用。<br>特别注意：<strong>当x特别大的时候，那一排的节点总数会特别大，直接相乘取模依然会溢出</strong>，所以要用一个<strong>分治策略</strong>来乘（<strong>快速乘</strong>函数q_mul）</li>
</ul>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> bin[<span class="number">63</span>];<span class="comment">//存每一排向右位移了多少格</span></span><br><span class="line"><span class="type">int</span> tmp[<span class="number">63</span>];<span class="comment">//临时存一下2的幂</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[n])<span class="keyword">return</span> tmp[n];</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        res*=<span class="number">2</span>;</span><br><span class="line">    tmp[n]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">q_mul</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//如果b的二进制末尾是零</span></span><br><span class="line">        &#123;</span><br><span class="line">            (sum += a)%=p;<span class="comment">//a要加上取余</span></span><br><span class="line">        &#125;</span><br><span class="line">        (a &lt;&lt;= <span class="number">1</span>)%=p;<span class="comment">//不断把a乘2相当于提高位数</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">//把b右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,k,l=<span class="number">-1</span>;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">            <span class="keyword">while</span>(x)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                x/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bin[l]+=k%(<span class="built_in">power</span>(l));</span><br><span class="line">            bin[l]%=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(bin[l]&lt;<span class="number">0</span>)bin[l]+=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+l&lt;<span class="number">63</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    bin[i+l]+=<span class="built_in">q_mul</span>(k,<span class="built_in">power</span>(i),<span class="built_in">power</span>(i+l));</span><br><span class="line">                    bin[i+l]%=<span class="built_in">power</span>(i+l);</span><br><span class="line">                    <span class="keyword">if</span>(bin[i+l]&lt;<span class="number">0</span>)bin[i+l]+=<span class="built_in">power</span>(i+l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x,y,l=<span class="number">-1</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            y=x;</span><br><span class="line">            <span class="keyword">while</span>(y)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                y/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            y=x-(<span class="built_in">power</span>(l));</span><br><span class="line">            y+=bin[l];</span><br><span class="line">            y%=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">while</span>(l)</span><br><span class="line">            &#123;</span><br><span class="line">                y/=<span class="number">2</span>;</span><br><span class="line">                l--;</span><br><span class="line">                y-=bin[l];</span><br><span class="line">                <span class="keyword">if</span>(y&lt;<span class="number">0</span>)y+=<span class="built_in">power</span>(l);</span><br><span class="line">                cout &lt;&lt; (<span class="built_in">power</span>(l))+y &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                y+=bin[l];</span><br><span class="line">                y%=<span class="built_in">power</span>(l);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>暴力</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-动态规划专题</title>
    <url>/article/4216/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>特别注意.size()的返回值是unsigned int，如果写出<code>i&lt;a.size()-1;</code>这样的判断条件是会出问题的，如果有负数，得写出<code>i&lt;(int)a.size()-1;</code><br><a href="https://codeforces.com/group/5FquYr3Pbe/contest/289105">测验传送门</a></p>
<span id="more"></span>
<h1 id="题目选集"><a href="#题目选集" class="headerlink" title="题目选集"></a>题目选集</h1><h2 id="J-Flood-Fill"><a href="#J-Flood-Fill" class="headerlink" title="J. Flood Fill"></a>J. Flood Fill</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<div style="text-align: center;">Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></div>
</blockquote>
<blockquote>
<p>You are given a line of $n$ colored squares in a row, numbered from $1$ to $n$ from left to right. The $i$-th square initially has the color $c_i$.<br>Let’s say, that two squares $i$ and $j$ belong to the same connected component if $c_i&#x3D;c_j$, and $c_i&#x3D;c_k$ for all $k$ satisfying $i&lt;k&lt;j$. In other words, all squares on the segment from $i$ to $j$ should have the same color.<br>For example, the line $[3,3,3]$ has $1$ connected component, while the line $[5,2,4,4]$ has $3$ connected components.<br>The game “flood fill” is played on the given line as follows:</p>
<ul>
<li>At the start of the game you pick any starting square (this is not counted as a turn).</li>
<li>Then, in each game turn, change the color of the connected component containing the starting square to any other color.<br>Find the minimum number of turns needed for the entire line to be changed into a single color.<br><strong>Input</strong><br>The first line contains a single integer $n\ (1≤n≤5000)$ — the number of squares.<br>The second line contains integers $c_1,c_2,…,c_n$ $(1≤c_i≤5000)$ — the initial colors of the squares.<br><strong>Output</strong><br>Print a single integer — the minimum number of the turns needed.</li>
</ul>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5 2 2 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4 5 2 2 1 3 5 5</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>连续相同的数字视为一个块，将一个块的所有数字变成另一个数字视为一次操作，给定一个数组，可以任选一个块作为开始，对起始块操作多少次能让所有数字相同</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先存数组，连续的数字只存一次<br>选起始块时发现，如果起始块左右分别有数字x，那么可以只操作一次同时消除两个x，但不能直接用栈来括号匹配，如1 2 3 1 2，如果选3作为起始块，至少要操作3次而不是2次<br>这个情况想到回文串，找出原数组<strong>最长回文串</strong>即可，那么问题又可以转化为找出原数组和其倒序数组的<strong>最长公共子序列</strong>，直接套用模板lcs函数求解</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn=<span class="number">5050</span>;</span><br><span class="line"><span class="type">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;a,vector&lt;<span class="type">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=a.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=b.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>]&gt;dp[i][j])dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>&gt;dp[i][j])</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a.<span class="built_in">size</span>()][b.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> n,l=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">a</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t!=l)a.<span class="built_in">push_back</span>(t);</span><br><span class="line">        l=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = a.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">b</span>(a);</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>()+<span class="number">1</span>,b.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; ans-<span class="built_in">lcs</span>(a,b)/<span class="number">2</span> &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Shaass-and-Bookshelf"><a href="#K-Shaass-and-Bookshelf" class="headerlink" title="K. Shaass and Bookshelf"></a>K. Shaass and Bookshelf</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<div style="text-align: center;">Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></div>
</blockquote>
<blockquote>
<p>Shaass has $n$ books. He wants to make a bookshelf for all his books. He wants the bookshelf’s dimensions to be as small as possible. The thickness of the $i$-th book is $t_i$ and its pages’ width is equal to $w_i$. The thickness of each book is either $1$ or $2$. All books have the same page heights.<br>Shaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.<br><img src="https://espresso.codeforces.com/343ded9fa106a8a70028e480d8dcf8721cf19f03.png" alt="Alt"><br>Help Shaass to find the minimum total thickness of the vertical books that we can achieve.<br><strong>Input</strong><br>The first line of the input contains an integer $n$, $(1 ≤ n ≤ 100)$. Each of the next $n$ lines contains two integers $t_i$ and $w_i$ denoting the thickness and width of the $i$-th book correspondingly, $(1 ≤ ti ≤ 2, 1 ≤ wi ≤ 100)$.<br><strong>Output</strong><br>On the only line of the output print the minimum total thickness of the vertical books that we can achieve.</p>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 12</span><br><span class="line">1 3</span><br><span class="line">2 15</span><br><span class="line">2 5</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 10</span><br><span class="line">2 1</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n本书的厚度和宽度，选一些竖着放，其他的横着放，但是要保证横着放的书的总宽度不大于竖着放的书的总厚度，求竖着放着的书最小总厚度</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>先假设每一本书都竖着，将这个问题看成<strong>01背包问题</strong>，每一本书视为一个货物，厚度与宽度的和视为体积，厚度视为价值，初始的总厚度视为背包容积，把一本书从竖着变成横着视为选择了这个货物，走一遍背包问题得到最大可以减少的厚度</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,sum=<span class="number">0</span>,dp[<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pii a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">        a[i].second+=a[i].first;</span><br><span class="line">        sum+=a[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=sum;j&gt;=a[i].second;j--)</span><br><span class="line">            dp[j]=dp[j]&gt;dp[j-a[i].second]+a[i].first?dp[j]:dp[j-a[i].second]+a[i].first;</span><br><span class="line">    cout &lt;&lt; sum - dp[sum];</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-数据结构专题</title>
    <url>/article/5872/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://codeforces.com/group/5FquYr3Pbe/contest/288107">测验传送门</a></p>
<span id="more"></span>
<h1 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h1><h2 id="A-Cells-Not-Under-Attack"><a href="#A-Cells-Not-Under-Attack" class="headerlink" title="A. Cells Not Under Attack"></a>A. Cells Not Under Attack</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>Vasya has the square chessboard of size $n × n$ and $m$ rooks. Initially the chessboard is empty. Vasya will consequently put the rooks on the board one after another.<br>The cell of the field is under rook’s attack, if there is at least one rook located in the same row or in the same column with this cell. If there is a rook located in the cell, this cell is also under attack.<br>You are given the positions of the board where Vasya will put rooks. For each rook you have to determine the number of cells which are not under attack after Vasya puts it on the board.<br><strong>Input</strong><br>The first line of the input contains two integers $n$ and $m$ $(1 ≤ n ≤ 100 000, 1 ≤ m ≤ min(100 000, n^2))$ — the size of the board and the number of rooks.<br>Each of the next m lines contains integers $x_i$ and $y_i$ $(1 ≤ x_i, y_i ≤ n)$ — the number of the row and the number of the column where Vasya will put the $i$-th rook. Vasya puts rooks on the board in the order they appear in the input. It is guaranteed that any cell will contain no more than one rook.<br><strong>Output</strong><br>Print $m$ integer, the $i$-th of them should be equal to the number of cells that are not under attack after first $i$ rooks are put.</p>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">3 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 5</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16 9</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 1</span><br><span class="line">300 400</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999800001</span><br></pre></td></tr></table></figure>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>向n*n的棋盘放置m颗棋子，与一个棋子同行或同列的格子视为被攻击。<br>每放置一颗棋子后，输出未受攻击的格子数量</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最后所有未受攻击的格子可以通过平移再组成一个大矩形，只需要用数组r和c记录哪些行和列受到了攻击，将未受攻击的行数和列数相乘就是答案</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="type">bool</span> r[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> a=n,b=n;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(!r[x])</span><br><span class="line">        &#123;</span><br><span class="line">            r[x]=<span class="number">1</span>;a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!c[y])</span><br><span class="line">        &#123;</span><br><span class="line">            c[y]=<span class="number">1</span>;b--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a * b &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Minimum-Array"><a href="#C-Minimum-Array" class="headerlink" title="C. Minimum Array"></a>C. Minimum Array</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are given two arrays a and b, both of length n. All elements of both arrays are from 0 to $n−1$.<br>You can reorder elements of the array b (if you want, you may leave the order of elements as it is). After that, let array c be the array of length n, the i-th element of this array is $c_i&#x3D;(a_i+b_i) % n $ , where $ x % y$ is x modulo y.<br>Your task is to reorder elements of the array b to obtain the <strong>lexicographically</strong> minimum possible array c.<br>Array x of length n is lexicographically less than array y of length n, if there exists such $i$ $(1≤i≤n)$, that $x_i&lt;y_i$, and for any $j$ $(1≤j&lt;i)$ $x_j&#x3D;y_j$.<br><strong>Input</strong><br>The first line of the input contains one integer $n$ $(1≤n≤2⋅10^5)$ — the number of elements in a, b and c.<br>The second line of the input contains n integers $a_1,a_2,…,a_n (0≤a_i&lt;n)$, where $a_i$ is the $i$-th element of $a$.<br>The third line of the input contains n integers $b_1,b_2,…,b_n (0≤b_i&lt;n)$, where $b_i$ is the $i$-th element of $b$.<br><strong>Output</strong><br>Print the <strong>lexicographically</strong> minimum possible array c. Recall that your task is to reorder elements of the array b and obtain the <strong>lexicographically</strong> minimum possible array c, where the $i$-th element of $c$ is $c_i&#x3D;(a_i+b_i)%n$.</p>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 2 1</span><br><span class="line">3 2 1 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 0 2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 5 1 5 3 4 3</span><br><span class="line">2 4 3 5 6 5 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 1 0 2 4</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>就给定a,b，b可以随意排序，c是a和b对应位置相加后模n，求如何排序b让c的字典序最小。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>贪心算法</strong>嘛，挺简单的，先给b排个序，每一步找最优解，从头开始，能找到n-a<del>i</del>就用，找不到就用比n-a<del>i</del>大且最小的值，没有更大的就用最小的。</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],c[maxn];</span><br><span class="line">multiset&lt;<span class="type">int</span>&gt;b;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="type">int</span> tmp;</span><br><span class="line">    	cin &gt;&gt; tmp;</span><br><span class="line">    	b.<span class="built_in">insert</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        multiset&lt;<span class="type">int</span>&gt;::iterator iter=b.<span class="built_in">lower_bound</span>(n-a[i]);</span><br><span class="line">	    <span class="keyword">if</span>(iter==b.<span class="built_in">end</span>())</span><br><span class="line">	    &#123;</span><br><span class="line">	    	c[i]=a[i]+*b.<span class="built_in">begin</span>();</span><br><span class="line">	    	b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(*iter==n-a[i]) b.<span class="built_in">erase</span>(iter);</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	c[i]=a[i]+*iter-n;</span><br><span class="line">	    	b.<span class="built_in">erase</span>(iter);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H-Subsegments"><a href="#H-Subsegments" class="headerlink" title="H. Subsegments"></a>H. Subsegments</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>Programmer Sasha has recently begun to study data structures. His coach Stas told him to solve the problem of finding a minimum on the segment of the array in $O(log\ n)$, which Sasha coped with. For Sasha not to think that he had learned all, Stas gave him a new task. For each segment of the fixed length Sasha must find the maximum element of those that occur on the given segment exactly once. Help Sasha solve this problem.<br><strong>Input</strong><br>The first line contains two positive integers n and k $(1 ≤ n ≤ 10^5, 1 ≤ k ≤ n) $— the number of array elements and the length of the segment.<br>Then follow n lines: the i-th one contains a single number $a_i ( - 10^9 ≤ a_i ≤ 10^9)$.<br><strong>Output</strong><br>Print n–k + 1 numbers, one per line: on the i-th line print of the maximum number of those numbers from the subarray $a_i\ ,a_i+1\ …\ a_i+k-1$ that occur in this subarray exactly 1 time. If there are no such numbers in this subarray, print “Nothing”.</p>
</blockquote>
<h3 id="测试样例-2"><a href="#测试样例-2" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">Nothing</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>就是一个滑动窗口，先取前k个数，找出只出现一次且最大的数，然后窗口向右移动一格再找，如此反复</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>运用<strong>单调队列</strong>的话不太好找只出现一次的数，干脆直接无脑set和map得了，用这两个挺简单就过了</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line">map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;m;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;s;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        q.<span class="built_in">push</span>(temp);</span><br><span class="line">        map&lt;<span class="type">int</span>,<span class="type">int</span>&gt;::iterator iter=m.<span class="built_in">find</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(iter==m.<span class="built_in">end</span>())&#123;m[temp]=<span class="number">1</span>;s.<span class="built_in">insert</span>(temp);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)&#123;m[temp]++;s.<span class="built_in">erase</span>(temp);&#125;</span><br><span class="line">        <span class="keyword">else</span> m[temp]++;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[q.<span class="built_in">front</span>()]==<span class="number">1</span>)&#123;m.<span class="built_in">erase</span>(q.<span class="built_in">front</span>());s.<span class="built_in">erase</span>(q.<span class="built_in">front</span>());&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[q.<span class="built_in">front</span>()]== <span class="number">2</span>)&#123;m[q.<span class="built_in">front</span>()]--;s.<span class="built_in">insert</span>(q.<span class="built_in">front</span>());&#125;</span><br><span class="line">            <span class="keyword">else</span> m[q.<span class="built_in">front</span>()]--;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())cout &lt;&lt; *--s.<span class="built_in">end</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Nothing&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-Little-Girl-and-Maximum-Sum"><a href="#I-Little-Girl-and-Maximum-Sum" class="headerlink" title="I. Little Girl and Maximum Sum"></a>I. Little Girl and Maximum Sum</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>The little girl loves the problems on array queries very much.<br>One day she came across a rather well-known problem: you’ve got an array of n elements (the elements of the array are indexed starting from 1); also, there are q queries, each one is defined by a pair of integers $l_i, r_i (1 ≤ l_i ≤ r_i ≤ n)$. You need to find for each query the sum of elements of the array with indexes from li to $r_i$, inclusive.<br>The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.<br><strong>Input</strong><br>The first line contains two space-separated integers $n (1 ≤ n ≤ 2·10^5)$ and $q (1 ≤ q ≤ 2·10^5)$ — the number of elements in the array and the number of queries, correspondingly.<br>The next line contains n space-separated integers $ai (1 ≤ a_i ≤ 2·10^5)$ — the array elements.<br>Each of the following q lines contains two space-separated integers $l_i$ and $r_i$ $(1 ≤ l_i ≤ r_i ≤ n)$ — the $i$-th query.<br><strong>Output</strong><br>In a single line print a single integer — the maximum sum of query replies after the array elements are reordered.</p>
</blockquote>
<h3 id="测试样例-3"><a href="#测试样例-3" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">5 3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">5 2 4 1 3</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一个数组，接下来每次操作对第l到r个数求和，问如何排序数组让最后求和后总和最大</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>非常简单的题，用<strong>前缀和</strong>和<strong>差分</strong>思想，得出每一位被加了多少次，然后把最大的数分配给被加了最多次的数，其余位置同理</p>
<h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n ,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        b[l]++;</span><br><span class="line">        b[r+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=b[i]+a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=a[i]*c[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Queries-about-less-or-equal-elements"><a href="#K-Queries-about-less-or-equal-elements" class="headerlink" title="K. Queries about less or equal elements"></a>K. Queries about less or equal elements</h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$.<br><strong>Input</strong><br>The first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$.<br>The second line contains $n$ integers — the elements of array $a ( -10^9 ≤ a_i ≤ 10^9)$.<br>The third line contains $m$ integers — the elements of array $b ( -10^9 ≤ b_j ≤ 10^9)$.<br><strong>Output</strong><br>Print $m$ integers, separated by spaces: the $j$-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$.</p>
</blockquote>
<h3 id="测试样例-4"><a href="#测试样例-4" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 3 5 7 9</span><br><span class="line">6 4 2 8</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2 1 4</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 1 2 5</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 4 2 5</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定数组a和b，对b的每个值找出a中有多少数小与等于该值</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>非常简单的题，先对a和b排序，然后运用<strong>双指针</strong>很快能做出</p>
<h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="type">int</span> a[maxn],c[maxn];</span><br><span class="line">pii b[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        b[i]=&#123;temp,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);<span class="built_in">sort</span>(b,b+m);</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=b[j].first)&#123;ans++;i++;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;c[b[j].second]=ans;j++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        c[b[j].second]=ans;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h1><h2 id="B-Too-Easy-Problems"><a href="#B-Too-Easy-Problems" class="headerlink" title="B. Too Easy Problems"></a>B. Too Easy Problems</h2><h3 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are preparing for an exam on scheduling theory. The exam will last for exactly T milliseconds and will consist of n problems. You can either solve problem  $i$  in exactly $t_i$ milliseconds or ignore it and spend no time. You don’t need time to rest after solving a problem, either.<br>Unfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer ai to every problem $i$ meaning that the problem $i$ can bring you a point to the final score only in case you have solved no more than ai problems overall (including problem $i$ ).<br>Formally, suppose you solve problems $p_1, p_2, …, p_k$ during the exam. Then, your final score s will be equal to the number of values of j between 1 and k such that $      k ≤ a_{p_j}$.<br>You have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don’t forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do.<br><strong>Input</strong><br>The first line contains two integers n and T ($1 ≤ n ≤ 2·10^5; 1 ≤ T ≤ 10^9$) — the number of problems in the exam and the length of the exam in milliseconds, respectively.<br>Each of the next n lines contains two integers ai and ti ($1 ≤ a_i ≤ n; 1 ≤ t_i ≤ 10^4$). The problems are numbered from 1 to $n$.<br><strong>Output</strong><br>In the first line, output a single integer s — your maximum possible final score.<br>In the second line, output a single integer $k$ $(0 ≤ k ≤ n)$ — the number of problems you should solve.<br>In the third line, output k distinct integers $p_1, p_2, …, p_k (1 ≤ p_i ≤ n)$ — the indexes of problems you should solve, in any order.<br>If there are several optimal sets of problems, you may output any of them.</p>
</blockquote>
<h3 id="测试样例-5"><a href="#测试样例-5" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 300</span><br><span class="line">3 100</span><br><span class="line">4 150</span><br><span class="line">4 80</span><br><span class="line">2 90</span><br><span class="line">2 300</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 100</span><br><span class="line">1 787</span><br><span class="line">2 788</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 100</span><br><span class="line">2 42</span><br><span class="line">2 58</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定题目数量n和考试时间T，做出每个题目需要的时间，还有题目的一个属性a。一开始没看懂这个a是什么意思，琢磨了一下样例发现是如果做出的总题目数超过a则这个题不给分，就是说a越小题目越简单，你做出了很多题这个题就不该得分（对dalao来说太简单了，但是对菜鸡还是得捞，得给分）。求最多能得到的分，最多能做出多少题，做出来的题目的题号。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题需要用到<strong>单调队列</strong>的思想，以a的值作为判断某个题的<strong>生存能力</strong>的大小，a更大的题，是更可能得分的题。先将所有题目的a值，编号，耗时记录下来，按照耗时大小排升序。先考虑最高得分，排完序一个题一个题读进单调队列（以a值为关键词升序排列）。<br>假设当前队列里有x个题，如果读到的题a &lt; x，那么做这道题无法得分；<br>如果a &#x3D; x，那么做这个题之后就a &lt; x了，要么舍弃这个题要么舍弃队首，但显然队首题目的a小与等于读进这个题目前的x，而且耗时还要更少，所以不做；<br>如果a &gt; x，做完可以加分，没问题，但是要考虑做题总数增加后队首题目是否还能有效给分，若队首不再合法，则又舍弃。<br>得到最高分后把选中的题目全部记录下来，从耗时最少的题目开始再遍历一遍，把多余的时间尽量做多的题目，得到最后答案<br><strong>注意：</strong> 得出最高得分后，最多完成的题目不可以超过队首的a值，如果多完成了题目，那么本来得分的题目又不得分了。</p>
<h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">p</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,i,m;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> p&amp; a) <span class="type">const</span><span class="comment">//定义排序方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a==a.a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==a.m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i &gt; a.i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m &gt; a.m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a &gt; a.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(p a,p b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.m&lt;b.m;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;p&gt;pq;</span><br><span class="line">p temp[maxn];</span><br><span class="line"><span class="type">bool</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//读入每道题的编号i 时间m 属性a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,m;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; m;</span><br><span class="line">        temp[i]=&#123;a,i,m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp+<span class="number">1</span>,temp+<span class="number">1</span>+n,cmp);<span class="comment">//以m为关键词排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;temp[i].m)<span class="keyword">break</span>;<span class="comment">//时间不够用了直接结束</span></span><br><span class="line">        <span class="keyword">if</span>(temp[i].a&gt;pq.<span class="built_in">size</span>())<span class="comment">//生存能力高的进队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(temp[i]);</span><br><span class="line">            t-=temp[i].m;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">top</span>().a&lt;pq.<span class="built_in">size</span>())<span class="comment">//淘汰队首生存能力差的</span></span><br><span class="line">            &#123;</span><br><span class="line">                t+=pq.<span class="built_in">top</span>().m;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> sum=pq.<span class="built_in">size</span>();<span class="comment">//最高得分</span></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> min = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans[pq.<span class="built_in">top</span>().i]=<span class="number">1</span>;<span class="comment">//记录已选题目编号</span></span><br><span class="line">        min=min&lt;pq.<span class="built_in">top</span>().a?min:pq.<span class="built_in">top</span>().a;<span class="comment">//记录最小的a</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;sum&lt;min;i++)<span class="comment">//注意加进来可能会导致原有题目不得分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;temp[i].m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ans[temp[i].i])</span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            t-=temp[i].m;</span><br><span class="line">            ans[temp[i].i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(ans[i])cout &lt;&lt; i &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E-Interesting-Array"><a href="#E-Interesting-Array" class="headerlink" title="E. Interesting Array"></a>E. Interesting Array</h2><h3 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>We’ll call an array of n non-negative integers a[1], a[2], …, a[n] interesting, if it meets m constraints. The i-th of the m constraints consists of three integers $l_i, r_i, q_i (1 ≤ l_i ≤ r_i ≤ n)$ meaning that value  should be equal to $q_i$.<br>Your task is to find any interesting array of n elements or state that such array doesn’t exist.<br>Expression x&amp;y means the bitwise AND of numbers x and y. In programming languages C++, Java and Python this operation is represented as “&amp;”, in Pascal — as “and”.<br><strong>Input</strong><br>The first line contains two integers n, m $(1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5)$ — the number of elements in the array and the number of limits.<br>Each of the next m lines contains three integers $l_i, r_i, q_i (1 ≤ l_i ≤ r_i ≤ n, 0 ≤ q_i &lt; 230)$ describing the i-th limit.<br><strong>Output</strong><br>If the interesting array exists, in the first line print “YES” (without the quotes) and in the second line print n integers a[1], a[2], …, a[n] (0 ≤ a[i] &lt; 230) decribing the interesting array. If there are multiple answers, print any of them.<br>If the interesting array doesn’t exist, print “NO” (without the quotes) in the single line.</p>
</blockquote>
<h3 id="测试样例-6"><a href="#测试样例-6" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">3 3 3</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 3 3</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>找到一个数列，每一个限制要求数列的第l个到第r个数按位与可以得到q。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>将每一位视作一个独立的部分。<br>先将所有要求与后为0的限制按优先l然后r排好序。<br>用<strong>前缀和</strong>和<strong>差分</strong>思想标记出每一个必须为1的位，若第l到r个数的某一位与运算得到1，则第l到r个数的该位都得为1，用t[l]++,和t[r+1]–来记录，最后前缀和得出必须为1的位。<br>然后，遍历一遍数组验证剩下的位均为0是否满足剩余的限制。</p>
<h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii pair<span class="string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">que</span><span class="comment">//question</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l,r,q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l==b.l)<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">que b[maxn];<span class="comment">//记录所有限制</span></span><br><span class="line"><span class="type">int</span> t[maxn],tt[maxn],a[<span class="number">31</span>][maxn];<span class="comment">//t差分数组，tt前缀和，a记录答案</span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i].l &gt;&gt; b[i].r &gt;&gt; b[i].q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b,b+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;pii&gt;p;<span class="comment">//记录要求与后为0的限制</span></span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in">sizeof</span>(tt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="comment">//处理每一条限制的第i位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=b[j].l,r=b[j].r;</span><br><span class="line">            <span class="keyword">if</span>(b[j].q&amp;<span class="number">1</span>)&#123;t[l]++;t[r+<span class="number">1</span>]--;&#125;<span class="comment">//要求与后为1用差分数组记录</span></span><br><span class="line">            <span class="keyword">else</span> p.<span class="built_in">push</span>(&#123;l,r&#125;);</span><br><span class="line">            b[j].q&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//标记那些必须为1的位</span></span><br><span class="line">        &#123;</span><br><span class="line">            tt[j]=t[j]+tt[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tt[j])a[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> iter=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l=p.<span class="built_in">front</span>().first,r=p.<span class="built_in">front</span>().second;</span><br><span class="line">            <span class="keyword">if</span>(iter&gt;r)&#123;cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//超过这条限制要求的区间还没找到可以填0的地方</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(iter&lt;l)iter=l;<span class="comment">//还没到l，中间没有做要求，那我们跳过，相当于默认填0</span></span><br><span class="line">            <span class="keyword">else</span> &#123;p.<span class="built_in">pop</span>();<span class="keyword">continue</span>;&#125;<span class="comment">//iter已经在l和r之间表示l和r种的iter位置已经确定可以填0了，直接跳过</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(iter&gt;r)&#123;cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(!tt[iter])</span><br><span class="line">                &#123;</span><br><span class="line">                    p.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> iter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//输出结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">            sum+=a[j][i]&lt;&lt;j;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析数组与指针</title>
    <url>/article/11681/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组存储与指针问题"><a href="#数组存储与指针问题" class="headerlink" title="数组存储与指针问题"></a>数组存储与指针问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>先定义$A_1$~$A_5$ 五个类型，请填写以下表格</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Declare</th>
<th align="center">sizeof $A_n$</th>
<th align="center">sizeof *$A_n$</th>
<th align="center">sizeof **$A_n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int $A_1$[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int *$A_2$[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int (*$A_3$)[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int *($A_4$[3][5])</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int (*$A_5$[3])[5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<span id="more"></span>
<h3 id="A-1"><a href="#A-1" class="headerlink" title="$A_1$"></a>$A_1$</h3><p>此为一个普通的二维数组，直接计算其sizeof即为计算其在内存中所占大小，*$A_1$为int [5]即一个长度为5的一维数组，**$A_1$为int即一个普通的int类型的数据。</p>
<p>以下标识了对应的<strong>数据类型</strong>，数据类型的后半部分标识是数组还是指针，前半部分表示数组&#x2F;指针对应元素的数据类型，在使用Visual Studio的调试功能时可以显示每个变量对应的数据类型</p>
<p>sizeof $A_1$&#x3D;3*5*4&#x3D;60   int [3][5]</p>
<p>sizeof *$A_1$&#x3D;5*4&#x3D;20  int [5]</p>
<p>sizeof **$A_1$&#x3D;4  int</p>
<h3 id="A-2"><a href="#A-2" class="headerlink" title="$A_2$"></a>$A_2$</h3><p>$A_2$同时与*和[]相连，[]优先级更高，则其为一个二维数组，数组的每一个元素为int*，即指针数组（装有指针的数组）。</p>
<p>sizeof $A_2$&#x3D;3*5*8&#x3D;120  int* [3][5]</p>
<p>sizeof *$A_2$&#x3D;5*8&#x3D;40  int* [5]</p>
<p>sizeof **$A_2$&#x3D;8  int*</p>
<h3 id="A-3"><a href="#A-3" class="headerlink" title="$A_3$"></a>$A_3$</h3><p>$A_3$同时与*和[]相连，但*处打了括号，故*的优先级更高，则其为一个数组指针（指向一个二维数组的指针），以下语句完全是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">5</span>] = *a;</span><br></pre></td></tr></table></figure>

<p><em>$A_3$的大小即是二维数组的大小，</em>*$A_3$即是一维数组的大小。</p>
<p>sizeof $A_3$&#x3D;8  int[3][5] *</p>
<p>sizeof *$A_3$&#x3D;3*5*4&#x3D;60  int [3][5]</p>
<p>sizeof **$A_3$&#x3D;5*4&#x3D;20  int [5]</p>
<h3 id="A-4"><a href="#A-4" class="headerlink" title="$A_4$"></a>$A_4$</h3><p>$A_4$同时与*和[]相连，[]本身优先级更高，加上括号性质不变，即情况同$A_2$。</p>
<p>sizeof $A_4$&#x3D;3*5*8&#x3D;120</p>
<p>sizeof *$A_4$&#x3D;5*8&#x3D;40</p>
<p>sizeof **$A_4$&#x3D;8</p>
<h3 id="A-5"><a href="#A-5" class="headerlink" title="$A_5$"></a>$A_5$</h3><p>(*$A_5$[3])代表$A_5$是一个长度为3的一维数组，数组的元素是指针，该指针的数据类型为int[5] *。</p>
<p>int[5] *，代表该元素是一个指针指向了长度为5的一维数组，数组中元素的数据类型为int。$A_5$的数据类型为int[5]* [3]。</p>
<p>sizeof $A_5$&#x3D;3*8&#x3D;24  int[5]* [3] （长为3的数组装着int[5]*）</p>
<p>sizeo *$A_5$&#x3D;8  int[5] *</p>
<p>sizeof **$A_5$&#x3D;5*2&#x3D;20  int [5]</p>
<p>经过以上的分析后，可得出最终答案为：</p>
<table>
<thead>
<tr>
<th align="center">Declare</th>
<th align="center">sizeof $A_n$</th>
<th align="center">sizeof *$A_n$</th>
<th align="center">sizeof **$A_n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int A1[3][5]</td>
<td align="center">60</td>
<td align="center">20</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">int *$A_2$[3][5]</td>
<td align="center">120</td>
<td align="center">40</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">int (*$A_3$)[3][5]</td>
<td align="center">8</td>
<td align="center">60</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">int *($A_4$[3][5])</td>
<td align="center">120</td>
<td align="center">40</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">int (*$A_5$[3])[5]</td>
<td align="center">24</td>
<td align="center">8</td>
<td align="center">20</td>
</tr>
</tbody></table>
<p>ps. $A_2$~$A_5$也可能是三维数组，此时一个指针所分配的空间长度不只是一个元素。</p>
<p>如果$A_2$中二维数组装着的int*实际上都是new出来的长16的数组，那么为什么此时sizeof依然不变呢？</p>
<p>对于int *a&#x3D;new int[16]，a虽然被分配了64个字节大小的空间，但是sizeof并不计算这64个字节，这个a和int b[16]都是一个长16的数组，但是a的数据类型是int *只被看成一个路牌，而b的数据类型是int [16]被sizeof看成整个空间</p>
<h2 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h2><p>int main()函数中其实存在参数，其完整表达形式应为int main(int argc, char **argv)。</p>
<p>当a.cpp编译成a.exe后 可以在命令行里输入参数，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a.exe -a -s -o</span><br></pre></td></tr></table></figure>

<p>此时这个时候argc是3（3个参数），argv则装着这三个参数。为什么用到了char**呢？这里举个例子：</p>
<p>当定义一个int数组时，需要先定义长度，比如int array[100]，array其中的元素最多为100个，而且即使用不到100个位置，也占用了400byte内存。</p>
<p>如何让使其不定长呢？先int* array &#x3D; new int[16]，当想扩容时，int* temp &#x3D; new int[32]，然后for循环把array复制进tmp，再array&#x3D;tmp，即扩容了一倍。</p>
<p>这种扩容<strong>不是在原来分配的地址上向周围扩容</strong>，而是新开辟一块更大空间并把原来的数据复制过去。</p>
<p>举个例子来说，一个人有一块封地，后来被天子赐予了一块更大的封地，这块封地是在一个任意未开发的位置选取的，而不是在他原来的封地上进行扩容，因为原来的位置周围可能已经被别人占用了。</p>
<p>那么为什么不先int array[16]，再int tmp[32]，for循环后再array&#x3D;tmp呢？那是因为<strong>数组可以看成const类型的指针</strong>，初始化后就不能再修改他的值也就是指向的地址，而指针可以修改他所指向的地址。以上面的例子来说，数组就是一块预先分配好的固定的封地，而指针分配的封地是可以变的，那么先分配小封地，用满了再分配大封地就是扩容的策略。这也是C++的STL中的vector所使用的策略，vector并不需要预先定义大小，只需要push_back就可以了，当预先分配的空间满载的时候就使用另一块更大的空间，复制原数据并回收原来的空间。</p>
<p>char**用的就是<strong>不定长的性质</strong>来代替定长的二维数组，用以有效利用内存。</p>
<p>注意：int *a&#x3D;new int[16]和int b[16]中a和b不同，前者是一个指针，导致了这样定义数组可扩容。后者是一个数组，长度是固定的，数组名的值和指针一样也是一个地址。指针和数组都指向一片地址，所以才说二者近似，但直接定义数组的空间是固定的，指针定义数组的空间是可变的，<strong>b是一个const类型的指针</strong>。</p>
<p>同时还有另一种扩容的策略。在STL的deque中除了push_back以外还可以push_front，那么前面这种策略就不适用了。deque先预先分配一段空间，当头插数据到顶端了或者尾插数据到顶端了，deque开辟一块内存在<strong>逻辑上</strong>和原内存前后相连，而vector是<strong>物理上</strong>连续的。deque这样的方式类似于链表，将一块块内存在逻辑上串联起来。</p>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>面向万物互联的终端操作系统设计与实现</title>
    <url>/article/54827/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><p> 　　我们正在进入物联网时代，各种智能设备除了相应的硬件之外，同样也需要运行操作系统进行软硬件的管理。相应地，操作系统须支持设备的多样性：功能多样性，支持简单数据采样，到较为复杂的数据预处理&#x2F;压缩&#x2F;推断等;硬件多样性，从最基本的温度传感器，到智能处理设备等，其CPU&#x2F;内存&#x2F;外存差异大，需要进行灵活配置。</p>
<p>　　本文结合国内外微内核操作系统设计了一款新型终端设备操作系统，并以核酸采样设备作为载体进行定制化，重点围绕设备管理、进程管理、内存管理、文件管理等组件进行深入研究，主要工作为以下几点。</p>
<p>　　（1）实现了对外部硬件设备的良好支持以及同宏内核一致的系统调用。</p>
<p>　　（2）为了满足核酸采样设备的定制化需要，该新型终端设备操作系统使用信号量实现了高效的同步算法，同时选择了合适的进程调度算法进行调度以避免过长的等待。</p>
<p>　　（3）采用页式储存管理和可变分配全局置换的页面分配策略进行内存管理，综合考虑缺页率和抖动现象，使得满足性能的同时，所需总的物理内存尽量小。</p>
<p>　　（4）针对核酸采样信息的结构化数据特性，采用B+树索引组织数据，定制化地设计了核酸采样信息的存取流程，优化了存储空间管理和外存数据读写的性能。</p>
<p><strong>关键词：物联网，微内核，操作系统</strong></p>
<span id="more"></span>

<h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><h2 id="1-1-微内核技术的发展"><a href="#1-1-微内核技术的发展" class="headerlink" title="1.1 微内核技术的发展"></a>1.1 微内核技术的发展</h2><p>　　随着IT技术的发展，计算机系统经历了主机&#x2F;服务器系统、桌面处理系统、手机移动系统等的发展，每种新形态的出现，也都有相应代表性的操作系统出现，并占市场主流。例如，服务器操作系统Unix，桌面操作系统Windows，手机操作系统Android&#x2F;IOS等。操作系统内核有两种形态，即宏内核和微内核，目前这些主流操作系统均是宏内核操作系统。</p>
<p>　　宏内核（Monolithic kernel）的架构特点是把所有操作系统功能放入内核进程中，整个内核程序都在内核空间（Kernel mode）下以监管者模式（Supervisor mode）的身份运行。宏内核的代码高度紧密，各个模块之间耦合性强，即使有些宏内核模式的操作系统将其运作从整体性运作拆成了多个服务模块，也会因为各个模块之间的强耦合性难以更换模块。同时，宏内核相对于微内核的功能边界更加不明确，不像微内核可以将一个功能的实现封闭在一个较小的模块中，宏内核更难以调试和维护。在出现错误时，宏内核一方面无法快速定位错误点，另一方面会由于一个功能内的错误导致整个内核崩溃。</p>
<p>　　为了解决上述问题，微内核（Micro kernel）设计理念被提出以对抗宏内核的各种缺点。</p>
<h2 id="1-2-微内核优势"><a href="#1-2-微内核优势" class="headerlink" title="1.2 微内核优势"></a>1.2 微内核优势</h2><p>　　（1）提高了系统的可扩展性。由于微内核操作系统的许多功能是由相对独立的服务器软件来实现的，当开发了新的硬件和软件时，微内核操作系统只须在相应的服务器中增加新的功能，或再增加一个专门的服务器。与此同时，也必然改善系统的灵活性，不仅可在操作系统中增加新的功能，还可修改原有功能，以及删除已过时的功能，以形成一个更为精干有效的操作系统。</p>
<p>　　（2）增强了系统的可靠性。由于所有服务器都是运行在用户态，服务器与服务器之间采用的是消息传递通信机制，因此，当某个服务器出现错误时，不会影响内核，也不会影响其它服务器。</p>
<p>　　（3）可移植性。在微内核结构的操作系统中，所有与特定CPU和I&#x2F;O设备硬件有关的代码，均放在内核和内核下面的硬件隐藏层中，而操作系统其它绝大部分(即各种服务器)均与硬件平台无关，因而，把操作系统移植到另一个计算机硬件平台上所需作的修改是比较小的。</p>
<p>　　（4）提供了对分布式系统的支持。由于在微内核操作系统中，客户和服务器之间以及服务器和服务器之间的通信，是采用消息传递通信机制进行的，致使微内核操作系统能很好地支持分布式系统和网络系统。</p>
<p>　　（5）融入了面向对象技术。</p>
<p>　　鉴于以上优势，本新型终端设备操作系统采用微内核架构进行设计，以此适应终端设备的软硬件多样性，在CPU&#x2F;内存&#x2F;外存差异巨大的情况下保持良好的效率、适应性和扩展性。</p>
<h1 id="二、整体设计"><a href="#二、整体设计" class="headerlink" title="二、整体设计"></a>二、整体设计</h1><h2 id="2-1-系统工作流程"><a href="#2-1-系统工作流程" class="headerlink" title="2.1 系统工作流程"></a>2.1 系统工作流程</h2><p>　　相对于宏内核将所有OS服务放入内核，并在内核模式下运行这些服务，微内核仅保留必须直接依赖于硬件的服务如进程间通信（IPC，inter-process communication）、任务调度（dispatcher）、低级内存管理（basic memory management）等。其他硬件无关的服务如设备驱动、文件系统、网络服务等都以服务器进程的形式运行在用户空间内。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220704060553156.png" alt="image-20220704060553156"></p>
<p>　　为了满足微内核的模块化设计需求，通过参考Minix R3.3.0的架构设计，本新型终端设备操作系统采用分层架构。系统架构分为服务接口层、服务层、内核接口层、内核层、硬件适配层。其中内核层负责实现微内核直接依赖于硬件的基本服务，通过调用硬件适配层来适应不同硬件如芯片、内存条的差异以提升操作系统的可移植性，并通过内核接口层向服务层提供接口。服务层模块化地实现了从宏内核中分离出来的系统服务如设备驱动、文件管理、网络服务，这些系统服务以分离的进程的形式运行，彼此之间互相隔离，通过内核层提供的IPC服务互相通信，并通过服务接口层向应用层提供接口。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220704024914963.png" alt="image-20220704024914963"></p>
<p>　　这种分层架构有利于适配多种多样的硬件平台，使得可移植性显著提升。</p>
<h2 id="2-2-系统对新硬件设备的支持"><a href="#2-2-系统对新硬件设备的支持" class="headerlink" title="2.2 系统对新硬件设备的支持"></a>2.2 系统对新硬件设备的支持</h2><p>　　当添加一个新硬件设备时，硬件适配层会将新硬件设备的驱动程序和中断处理程序载入以创建一个新的服务器进程。当用户进程执行I&#x2F;O操作时，调用的接口和宏内核一致，但是实现方式从宏内核的直接函数调用方式替换为了进程间通信方式。</p>
<p>　　以read系统调用为例，当一个用户进程执行read系统调用时，会使用内核层的IPC服务向文件系统进程发送消息。文件系统进程收到消息后再向设备驱动进程发送消息，随后设备驱动进程会调用相应外部设备的控制器进行读取操作。设备控制器将读取到的数据放入缓冲区后，设备驱动程序执行系统调用请求内核将设备控制器缓冲区的数据拷贝至文件系统进程的缓冲区，接着文件系统进程执行系统再调用请求内核将数据拷贝至用户进程的缓冲区中。</p>
<pre class="mermaid">sequenceDiagram
 participant us as 用户进程
 participant fs as 文件系统
 participant dr as 设备驱动
 participant dc as 设备控制器
 participant kn as 内核
 us->>+fs:read()
 fs->>+dr:dev_io()
 dr->>+dc:do_transfer()
 dc-->>-dr:return
 dr->>+kn:sys_insw()
 kn-->>-dr:return
 dr-->>-fs:return
 fs->>+kn:sys_copy()
 kn-->>-fs:return
 fs-->>-us:return</pre>

<h1 id="三、进程管理"><a href="#三、进程管理" class="headerlink" title="三、进程管理"></a>三、进程管理</h1><h2 id="3-1-进程控制块"><a href="#3-1-进程控制块" class="headerlink" title="3.1 进程控制块"></a>3.1 进程控制块</h2><p>　　系统使用进程控制块（PCB）数据结构来维护与进程相关的具体信息。进程相关的信息包括进程 id，休眠时间，进程时间片，进程状态，进程优先级，进程通信IPC缓存，进程地址空间，进程异常处理函数指针，进程异常号，进程调用终端，进程回应调用者列表，进程调用者列表，进程当前所在列表，进程列表节点，进程名，进程上下文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pcb</span> &#123;</span></span><br><span class="line">    <span class="type">int32_t</span> pid;</span><br><span class="line">    <span class="type">int32_t</span> ppid;</span><br><span class="line">    <span class="type">int8_t</span> priority;</span><br><span class="line">    <span class="type">int8_t</span> status;</span><br><span class="line">    <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">ctx_t</span> context;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-进程同步"><a href="#3-2-进程同步" class="headerlink" title="3.2 进程同步"></a>3.2 进程同步</h2><p>　　在核酸检测过程中，为了满足进程的同步与互斥，采样机械臂的驱动程序和识别扫码仪的驱动程序需要使用操作系统提供的信号量机制来完成任务。信号量（Semaphore）又称为信号量、旗语，是一个同步对象，用于实现进程间的同步与互斥。进程通过对信号量的P操作和V操作来获取或释放资源。核酸检测中的同步问题可以看成多个消费者和多个生产者的消费者-生产者问题，据此可以设计出如下同步算法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semophore full = <span class="number">0</span>, empty = k, mutex = <span class="number">1</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">waitng_list_head</span>, <span class="title">waiting_list_tail</span>;</span> <span class="comment">//等待队列指针</span></span><br><span class="line"></span><br><span class="line">cobegin</span><br><span class="line"><span class="type">void</span> <span class="title function_">machine_arm</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex); <span class="comment">//获取互斥锁</span></span><br><span class="line">    P(full); <span class="comment">//等待等待队列有空闲位置</span></span><br><span class="line">    <span class="comment">//执行采样，删除等待队列头部的数据</span></span><br><span class="line">    V(mutex); <span class="comment">//释放互斥锁</span></span><br><span class="line">    V(empty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">scanner</span><span class="params">()</span> &#123;</span><br><span class="line">    P(mutex); <span class="comment">//获取互斥锁</span></span><br><span class="line">    P(empty); <span class="comment">//等待等待队列有空闲位置</span></span><br><span class="line">    <span class="comment">//允许扫码，将扫码后新获取的信息插入等待队列尾部</span></span><br><span class="line">    V(mutex); <span class="comment">//释放互斥锁</span></span><br><span class="line">    V(full);</span><br><span class="line">&#125;</span><br><span class="line">coend</span><br></pre></td></tr></table></figure>

<p>　　该算法实现了进程间的高效同步，确保了进程并行运行时不会出现脏读、幻读等错误。</p>
<h2 id="3-3-进程监控"><a href="#3-3-进程监控" class="headerlink" title="3.3 进程监控"></a>3.3 进程监控</h2><p>　　为了避免核酸检测站点的人员过于密集，采样设备应该实现进程的追踪与监控。通过记录机械采样臂和识别扫码仪的开始处理时间和结束处理时间来计算完成一次核酸检测所花费的时间，并将这个指标与人员到达速率进行比较。</p>
<p>　　用来判断是否人员过于密集的公式如下:<br>$$<br>\min(机械采样臂处理速率,识别扫码仪处理速率)&lt;人员到达速率<br>$$<br>　　若满足上列公式，则认为人员过于密集，需要广播该采样点人员过多的提示音。</p>
<h2 id="3-4-进程调度"><a href="#3-4-进程调度" class="headerlink" title="3.4 进程调度"></a>3.4 进程调度</h2><p>　　为了满足核酸检测过程中采样机械臂的快速重采样要求，本新型终端设备操作系统的任务调度模块支持基于优先级的多级队列调度算法和时间轮转片调度算法，操作系统采用位图管理任务的优先级。应用任务可以通过接口创建另一个任务，并设置该任务的优先级。出于安全性考虑，当一个任务创建另外一个任务时，只能把另外一个任务优先级设置不高于该任务，即任务不能创建比自己优先级还高的子任务。操作系统为每一个优先级维护一个就绪队列，每次调度时选取最高优先级且非空的就绪队列，对相同优先级的任务采取时间轮转片调度算法进行调度。</p>
<p>　　当采样机械臂人脸定位识别失败后进行重采样时，临时提高采样机械臂进程的优先级，若此次人脸定位成功，在采样后重置为默认优先级，否则继续提高采样机械臂进程的优先级直到优先级达到用户进程的最高优先级。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220704175301205.png" alt="image-20220704175301205"></p>
<p>　　通过这种老化策略来保证采样机械臂在人脸定位失败后能够快速的重采样以避免被采样者等待过长时间，解决了采样机械臂可能存在的饥饿问题。</p>
<h1 id="四、内存管理"><a href="#四、内存管理" class="headerlink" title="四、内存管理"></a>四、内存管理</h1><h2 id="4-1-物理页面分配"><a href="#4-1-物理页面分配" class="headerlink" title="4.1 物理页面分配"></a>4.1 物理页面分配</h2><p>　　为了适应终端设备的多样性，支持差异巨大的软件、硬件，本新型终端设备操作系统的物理页面分配策略采用可变分配全局置换策略。内存管理服务器刚开始会为每个进程分配一定数量的物理页面，同时会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理页面中取出一页分配给该进程；若已无空闲物理页面，则可选择一个未锁定的页面换出外存，再将该物理页面分配给缺页的进程。采用这种策略时，只要某进程发生缺页都将获得新的物理页面，仅当空闲物理页面用完时，系统才选择一个未锁定的页面调出。被选择调出的页面可能是系统中任何一个进程中的页面，因此这个被选中的进程拥有的物理页面会减少，发出请求的进程拥有的物理页面会增多。通过这种方式内存管理进程可以动态调节每个进程拥有的物理页面，有利于复用空闲的物理页面，将这些空闲的物理页面重新分配给物理页面不足的进程，以此降低缺页率。</p>
<p>　　调页策略采用预调页和请求调页结合的方式，在进程加载、重启时预先调入多个相邻页面，这些页面必然会在不久的将来被使用，提前将这些页面加载到内存中可以减少I&#x2F;O次数，提高内存管理进程的效率。进程在运行过程中采取惰性加载措施，只在发生缺页时向内存管理进程请求调入缺失的页面。</p>
<h2 id="4-2-页面置换"><a href="#4-2-页面置换" class="headerlink" title="4.2 页面置换"></a>4.2 页面置换</h2><p>　　当物理页面全部分配后，进程再次发生缺页，为了将进程需要的物理页面调入，必须先将一个已经分配出去的页面调出，选择被淘汰页面的方式有很多种类，其中常见的页面置换算法有先进先出置换算法（FIFO）、最近最久未使用置换算法（LRU）、第二次机会置换算法、时钟置换算法、最不常用置换算法（LFU）。其中LRU置换算法效率最佳，且不会出现belady异常，最接近最佳置换算法（OPT）的性能，但是需要大量软件和硬件的支持，不利于支持硬件设备的多样性，因而选择近似LRU的时钟置换算法作为替代。</p>
<p>　　最简单的时钟策略需要给每一页框关联一个附加位，称为使用位。当某一页首次装入内存中时，则将该页页框的使用位设置为1；当该页随后被访问到时（在访问产生缺页中断之后），它的使用位也会被设置为1。该方法中，用于置换的候选页框集合被看做是一个循环缓冲区，并且有一个指针针与之相关联。当一页被置换时，该指针针被设置成指向缓冲区中的下一页框。当需要置换一页时，操作系统扫描缓冲区，以查找使用位被置为0的一页框。每当遇到一个使用位为1的页框时，操作系统就将该位重新置为0；如果在这个过程开始时，缓冲区中所有页框的使用位均为0时，则选择遇到的第一个页框置换；如果所有页框的使用位均为1时，则指针针在缓冲区中完整地循环一周，把所有使用位都置为0，并且停留在最初的位置上，置换该页框中的页。当需要使用的页已经存在时，则指针不会受到影响，不会发生转动。</p>
<p>![未命名文件 (2)](<a href="https://picture-bed-1306010815.file.myqcloud.com/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6">https://picture-bed-1306010815.file.myqcloud.com/未命名文件</a> (2).png)</p>
<p>　　可见该策略类似于FIFO置换算法，唯一不同的是，在时钟策略中使用位为1的页框被跳过，该策略之所以称为时钟策略，是因为可以把页框形象地想象成在一个环中。许多操作系统都采用这种简单时钟策略的某种变体。</p>
<h1 id="五、文件系统"><a href="#五、文件系统" class="headerlink" title="五、文件系统"></a>五、文件系统</h1><h2 id="5-1-设计思路"><a href="#5-1-设计思路" class="headerlink" title="5.1 设计思路"></a>5.1 设计思路</h2><p>　　面对高度结构化数据的存储时，可以仿照数据库管理机制对数据建立索引进行维护。参考Mysql设计原理，本新型终端设备操作系统采用B+树来组织和维护核酸采样信息。B+树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。B+树元素自底向上插入，这与二叉树恰好相反。</p>
<p>　　B+树在节点访问时间远远超过节点内部访问时间的时候，比红黑树、AVL树等数据结构有着显著的优势。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。这种价值得以确立通常需要每个节点在次级存储中占据完整的磁盘块或近似的大小。B+背后的想法是内部节点可以有在预定范围内的可变数目的子节点。因此，B+树不需要象其他自平衡二叉查找树那样经常的重新平衡。对于特定的实现在子节点数目上的低和高边界是固定的。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/%E5%AD%90%E9%9B%86%E9%97%AE%E9%A2%98%E8%A7%A3%E7%A9%BA%E9%97%B4%E6%A0%91.png" alt="子集问题解空间树"></p>
<h2 id="5-2-具体应用"><a href="#5-2-具体应用" class="headerlink" title="5.2 具体应用"></a>5.2 具体应用</h2><p>　　以此为基础，将核酸采样信息的每条记录记为一行，将试管编号作为主键建立B+树，同时允许选择性地为其他可以作为查询关键词的属性建立B+树索引，如身份证号码、采样时间、采样点代码。非主键上的B+树索引不携带行数据，需要回表查询，牺牲了一些性能但节省了大量的储存空间。</p>
<p>　　由于核酸采样信息具有不频繁更新或从不更新的性质，且增删频率相对于计算机运行速度来说极低，在更新数据时选择采用序列化的方式来保证一致性，在并行运行的情况下一次只有一个进程可以操作核酸采样信息，其他需要操作核酸采样信息的进程会陷入阻塞，直到可以操作数据时重新进入就绪队列。通过运用B+树，对核酸采样信息的增删改查操作的复杂度都降为$O(\log n)$，且支持范围查询。</p>
<h1 id="六、总结与展望"><a href="#六、总结与展望" class="headerlink" title="六、总结与展望"></a>六、总结与展望</h1><h2 id="6-1-全文工作总结"><a href="#6-1-全文工作总结" class="headerlink" title="6.1 全文工作总结"></a>6.1 全文工作总结</h2><p>　　本文基于对支持万物互联的新型操作系统进行研究，首先介绍了微内核技术的发展与优势，展示了该新型终端设备操作系统的整体设计架构与工作流程。随后以全自动核酸采样设备作为载体，进一步细化设计目标，详细地介绍了用以适配该终端设备的进程管理系统、内存管理系统和文件管理系统的设计方案与工作细节。</p>
<h2 id="6-2-存在的不足"><a href="#6-2-存在的不足" class="headerlink" title="6.2 存在的不足"></a>6.2 存在的不足</h2><p>　　微内核操作系统设计的研究内容非常广，工作量巨大，所以在设计过程中难免有考虑不周的地方。本新型终端设备操作系统的缺点主要体现在以下几个方面：</p>
<p>　　（1）未实现高效的进程间通信服务，采用内存拷贝的消息传递方式开销较大。</p>
<p>　　（2）不支持实时进程调度。</p>
<h2 id="6-3-未来的研究与展望"><a href="#6-3-未来的研究与展望" class="headerlink" title="6.3 未来的研究与展望"></a>6.3 未来的研究与展望</h2><p>　　本研究以开发一款能够支持万物互联的微内核操作系统为目标，将继续开展更加深入的研究，下一步的工作目标包括：</p>
<p>　　（1）进一步完善进程间通信服务，借鉴seL4微内核采用寄存器传递消息的方式提高进程间通信的效率。</p>
<p>　　（2）研究微内核系统服务对实时性的支持。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]彭星海.基于X86架构的微内核操作系统的研究和实现[D].成都:电子科技大学, 2020.</p>
<p>[2]林禹清.面向控制领域的微内核系统服务的设计与实现[D].成都:电子科技大学,2019.</p>
<p>[3]王训,周东红.微内核操作系统的发展与关键技术解析[J].自动化博览,2022(03):56-61.</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>物联网</tag>
        <tag>微内核</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发抢课系统后端架构设计</title>
    <url>/article/15650/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h1><p>本项目使用nginx作为接入层处理用户的http请求，并负载均衡地分发请求到多个后端服务器上。</p>
<p>后端服务器使用django框架搭建application，使用uWSGI作为Web服务器。</p>
<span id="more"></span>

<p><img src="https://picture-bed-1306010815.file.myqcloud.com/1A9DE2FEFD2FCE5C59A02412889A9D9D.jpg" alt="img"></p>
<p>数据储存方面使用腾讯云的云原生mysql数据库来保障数据库服务的高可用性（主备同步保证可用）和单表性能（避免在大量数据情况下的分库分表），使用redis储存抢课时快速更新的热数据和实现消息队列。</p>
<blockquote>
<p>mysql可以进一步替换为postgresql，使用其倒排索引gin优化模糊搜素的效率。</p>
</blockquote>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><ul>
<li><p>后端服务器提供无状态服务，各服务器间相互独立，一台服务器宕机不影响其他服务器提供服务</p>
</li>
<li><p>redis采用3主3备的cluster集群部署方式避免单点故障，并实现了数据的分布式储存。cluster集群的无中心结构有利于动态增删节点，抵抗偶发故障</p>
<p>（服务器A、B、C分别有一个master节点和slave节点，A的slave节点跟踪B的master节点，B的slave节点跟踪C的master节点，C的slave节点跟踪A的master节点，假设服务器A挂了，服务器C的slave节点会接替服务器A的master节点工作）</p>
</li>
</ul>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220617141938252.png" alt="image-20220617141938252"></p>
<h1 id="高并发-x2F-高性能"><a href="#高并发-x2F-高性能" class="headerlink" title="高并发&#x2F;高性能"></a>高并发&#x2F;高性能</h1><h2 id="运维方面"><a href="#运维方面" class="headerlink" title="运维方面"></a>运维方面</h2><ul>
<li><p>放开linux内核对打开文件数的限制以及最大socket连接数的限制</p>
</li>
<li><p>使用nginx处理网络请求</p>
<ul>
<li>使用epoll实现IO多路复用</li>
<li>开启互斥锁避免epoll的惊群效应</li>
<li>通过top指令监控linux负载情况合理地设置负载均衡的权重</li>
</ul>
</li>
<li><p>使用C语言编写的uWSGI服务器替换django自带的WSGI服务器</p>
<ul>
<li>降低内存占用</li>
<li>提升响应时间</li>
<li>详尽的日志功能（在调试过程中发挥了极大作用）</li>
<li>高度可配置（比如进程在处理多少请求后重启，一定程度上对抗内存泄漏）</li>
</ul>
<blockquote>
<p>uWSGI和uwsgi的优质理解：<a href="https://xiaorui.cc/archives/4264">深入理解uwsgi和gunicorn网络模型</a>。</p>
</blockquote>
</li>
</ul>
<p><img src="https://pic1.zhimg.com/v2-e80ff00c68688062b6ebaae48c30db70_b.jpg" alt="img"></p>
<p>上图稍微有些错误，uWSGI服务器和django使用WSGI协议进行交流，而uwsgi协议是uWSGI服务器与Nginx交流的手段之一。</p>
<ul>
<li>使用腾讯云的CDN分发静态文件，将静态文件传输的任务从云服务器上剥离开，节约带宽以提供更高的并发量</li>
</ul>
<p><img src="https://pic3.zhimg.com/80/v2-5ff8be3f5882508abd7f27fc09891943_1440w.jpg?source=1940ef5c" alt="img"></p>
<p>经过一些列优化后使用apache bench压测得到的指数显著提升。</p>
<h2 id="代码方面"><a href="#代码方面" class="headerlink" title="代码方面"></a>代码方面</h2><p>核心思想是尽量<strong>减少网络io导致的阻塞</strong>，以此减少线程切换造成的消耗。</p>
<ul>
<li>将抢课的业务逻辑拆分，用redis储存课程剩余名额数，如果学生抢课成功，将消息存进list后直接响应请求，抢课成功后对数据库的操作将异步执行。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监听消息队列的部分</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Command</span>(<span class="title class_ inherited__">BaseCommand</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle</span>(<span class="params">self, *args, **options</span>):</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            user_id = <span class="built_in">int</span>(redis_conn.brpop(<span class="string">&#x27;enrollment_queue&#x27;</span>, <span class="number">0</span>)[<span class="number">1</span>])</span><br><span class="line">            curriculum_id = <span class="built_in">int</span>(redis_conn.brpop(<span class="string">&#x27;enrollment_queue&#x27;</span>, <span class="number">0</span>)[<span class="number">1</span>])</span><br><span class="line">            user = User.objects.get(pk=user_id)</span><br><span class="line">            curriculum = Curriculum.objects.get(pk=curriculum_id)</span><br><span class="line">            curriculum.student.add(user)</span><br><span class="line">            <span class="keyword">if</span> settings.DEBUG:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;用户：%s 抢到了课程：%s&quot;</span> % (user.username, curriculum.name))</span><br></pre></td></tr></table></figure>

<ul>
<li>使用lua脚本合并多次redis命令，减少网络io阻塞次数。</li>
</ul>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在3台2核云服务器的条件下（其中一台负责运行nginx，每台都有2个redis实例和1个django实例），优化前直接连接django的最大tps低于100，使用uwsgi后最大tps达到了5300，cpu利用率在95%以上。</p>
<p>在并发量为1000的情况下90%的请求延迟小于0.5s。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220612172810846.png" alt="image-20220612172810846"></p>
<p>在并发量为5000的情况下90%的请求延迟小于1.5秒。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220612172652723.png" alt="image-20220612172652723"></p>
<p>在并发量为1W的情况下90%的请求延迟小于2.5s。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220612172857531.png" alt="image-20220612172857531"></p>
<h1 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h1><p>通过lua脚本的原子性保证学生抢课不会发生超选或名额空缺。</p>
<p>抢课逻辑：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> has_selected = redis.call(<span class="string">&quot;sadd&quot;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">if</span> has_selected ~= <span class="number">1</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> count = redis.call(<span class="string">&quot;hincrby&quot;</span>,<span class="string">&quot;curriculum&quot;</span>,ARGV[<span class="number">1</span>],<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">if</span> count &lt; <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">redis.call(<span class="string">&quot;lpush&quot;</span>,<span class="string">&quot;enrollment_queue&quot;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])</span><br><span class="line">redis.call(<span class="string">&quot;sadd&quot;</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的脚本在以cluster模式部署redis出现了错误，原因是lua脚本中访问的key必须在同一个node上，解决方法参考以下博文：</p>
<p><a href="https://blog.csdn.net/qq_20128967/article/details/108611161">Redis Cluster中使用Lua脚本</a></p>
<p><a href="https://blog.csdn.net/damanchen/article/details/100584171">redis cluster怎么保证键的均匀分配（crc16算法）</a></p>
</blockquote>
<h1 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h1><ul>
<li><p>良好的编程风格，依据PEP8编程规范进行编程</p>
</li>
<li><p>统一的响应管理</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    body = json.loads(request.body)</span><br><span class="line">    curriculum_id = body[<span class="string">&#x27;curriculum_id&#x27;</span>]</span><br><span class="line"><span class="keyword">except</span> (KeyError, JSONDecodeError):</span><br><span class="line">    <span class="keyword">return</span> Results.illegal_argument</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    user_id = request.session[<span class="string">&#x27;id&#x27;</span>]</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        <span class="keyword">return</span> Results.not_login</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> res == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> Result(data_message=<span class="string">&quot;抢课成功&quot;</span>).to_response()</span><br><span class="line"><span class="keyword">elif</span> res == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> Result(data_message=<span class="string">&quot;抢课失败：已选该课程&quot;</span>, status=<span class="literal">False</span>).to_response()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> Result(data_message=<span class="string">&quot;抢课失败：人数已达上限&quot;</span>, status=<span class="literal">False</span>).to_response()</span><br></pre></td></tr></table></figure>

<h1 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h1><ul>
<li>后端使用jwt完成认证的功能，登录信息保存在浏览器而不是服务器内，后端服务器是完全无状态的</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/900b3e81f832b2f08c2e8aabb540536a.png" alt="img"></p>
<ul>
<li><p>采用python开发，可移植性强</p>
<ul>
<li>python本身有跨平台的特性，易于移植到其他平台上</li>
<li>使用pipreqs工具，自动检测项目的第三方库依赖，安装简单</li>
<li>django提供的migration功能降低了迁移数据库和更换数据库系统的难度</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>高并发</tag>
        <tag>redis</tag>
        <tag>nginx</tag>
        <tag>uWSGI</tag>
      </tags>
  </entry>
</search>
