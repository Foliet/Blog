<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于阿克尚的一些看法</title>
    <url>/categories/%E6%B8%B8%E6%88%8F/LOL/%E5%85%B3%E4%BA%8E%E9%98%BF%E5%85%8B%E5%B0%9A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>沉迷阿克尚无法自拔中，这英雄等他上赛场肯定得削，太强了，和别的英雄对比起来确实太强了。</p>
<p>看这恐怖的对线压制力<br><video src="https://cloud.morty.ltd:4000/lol/2021/08/13/1.mp4" controls="controls" style="max-width: 65%; display: block; margin-left: 1px; margin-right: auto;"><br>你的浏览器不支持播放该视频<br></video></p>
<span id="more"></span>
<p>打这种短手的真的是随便A他，走上去不让对面吃兵，来人立刻E钩墙拉开，注意站在一个刚好可以勾到河道墙的位置<br>抢个二级可以凶一下，对面身上有被动时E过去，在快碰到对方前下来，保持一个平A极限射程，但是如果打远程英雄是可以考虑直接E到脸上去A的<br>这波单杀最后其实是可以走的，觉得自己能打过兰博E了另一面墙，E自己家墙是可以直接翻到红buff墙边上的<br>阿克尚超强的机动性完全允许站在对方塔面前压制对面，来人赶紧E走，但是再E冷却转好之前不要往前走，这个时候是很脆弱的</p>
<p>参与团战刚开始不要进场，边上ob，有残血先在远处放大摸奖，尽量找好位置放极限E，仅仅挨着一点点墙是不会下来的，可以蹭过去，当自己从潜行出来贴着墙时稍微走出来一点，对准远处放E。如果贴脸E相当于控自己，极限E是可以飞很远的，而且伤害巨高（同时附带攻击特效比如说海妖）<br><video src="https://cloud.morty.ltd:4000/lol/2021/08/13/2.mp4" controls="controls" style="max-width: 65%; display: block; margin-left: 1px; margin-right: auto;"><br>你的浏览器不支持播放该视频<br></video></p>
]]></content>
      <categories>
        <category>游戏</category>
        <category>LOL</category>
      </categories>
      <tags>
        <tag>阿克尚</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-动态规划专题</title>
    <url>/categories/CPP/ACM/%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>属实是被dp问题吊打，对我来说还是太难了吧，又是树上dp又是图上dp，terrible<br>oh对了，特别注意.size()的返回值是unsigned int，如果写出<code>i&lt;a.size()-1;</code>这样的判断条件是会出问题的，如果有负数，得写出<code>i&lt;(int)a.size()-1;</code><br><a href="https://codeforces.com/group/5FquYr3Pbe/contest/289105">测验传送门</a></p>
<span id="more"></span>
<h1 id="题目选集"><a href="#题目选集" class="headerlink" title="题目选集"></a>题目选集</h1><h2 id="J-Flood-Fill"><a href="#J-Flood-Fill" class="headerlink" title="J. Flood Fill"></a>J. Flood Fill</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are given a line of $n$ colored squares in a row, numbered from $1$ to $n$ from left to right. The $i$-th square initially has the color $c_i$.<br>Let’s say, that two squares $i$ and $j$ belong to the same connected component if $c_i=c_j$, and $c_i=c_k$ for all $k$ satisfying $i&lt;k&lt;j$. In other words, all squares on the segment from $i$ to $j$ should have the same color.<br>For example, the line $[3,3,3]$ has $1$ connected component, while the line $[5,2,4,4]$ has $3$ connected components.<br>The game “flood fill” is played on the given line as follows:</p>
<ul>
<li>At the start of the game you pick any starting square (this is not counted as a turn).</li>
<li>Then, in each game turn, change the color of the connected component containing the starting square to any other color.<br>Find the minimum number of turns needed for the entire line to be changed into a single color.</li>
</ul>
<p><strong>Input</strong><br>The first line contains a single integer $n\ (1≤n≤5000)$ — the number of squares.<br>The second line contains integers $c_1,c_2,…,c_n$ $(1≤c_i≤5000)$ — the initial colors of the squares.<br><strong>Output</strong><br>Print a single integer — the minimum number of the turns needed.</p>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5 2 2 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">4 5 2 2 1 3 5 5</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>连续相同的数字视为一个块，将一个块的所有数字变成另一个数字视为一次操作，给定一个数组，可以任选一个块作为开始，对起始块操作多少次能让所有数字相同</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>先存数组，连续的数字只存一次<br>选起始块时发现，如果起始块左右分别有数字x，那么可以只操作一次同时消除两个x，但不能直接用栈来括号匹配，如1 2 3 1 2，如果选3作为起始块，至少要操作3次而不是2次<br>这个情况想到回文串，找出原数组<strong>最长回文串</strong>即可，那么问题又可以转化为找出原数组和其倒序数组的<strong>最长公共子序列</strong>，直接套用模板lcs函数求解</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">5050</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp;a,vector&lt;<span class="keyword">int</span>&gt;&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a.<span class="built_in">size</span>();i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=b.<span class="built_in">size</span>();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>]&gt;dp[i][j])dp[i][j]=dp[i][j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j]&amp;&amp;dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>&gt;dp[i][j])</span><br><span class="line">            dp[i][j]=dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[a.<span class="built_in">size</span>()][b.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> n,l=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">a</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t!=l)a.<span class="built_in">push_back</span>(t);</span><br><span class="line">        l=t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = a.<span class="built_in">size</span>()<span class="number">-2</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;<span class="built_in">b</span>(a);</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>()+<span class="number">1</span>,b.<span class="built_in">end</span>());</span><br><span class="line">	cout &lt;&lt; ans-<span class="built_in">lcs</span>(a,b)/<span class="number">2</span> &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Shaass-and-Bookshelf"><a href="#K-Shaass-and-Bookshelf" class="headerlink" title="K. Shaass and Bookshelf"></a>K. Shaass and Bookshelf</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>Shaass has $n$ books. He wants to make a bookshelf for all his books. He wants the bookshelf’s dimensions to be as small as possible. The thickness of the $i$-th book is $t_i$ and its pages’ width is equal to $w_i$. The thickness of each book is either $1$ or $2$. All books have the same page heights.<br>Shaass puts the books on the bookshelf in the following way. First he selects some of the books and put them vertically. Then he puts the rest of the books horizontally above the vertical books. The sum of the widths of the horizontal books must be no more than the total thickness of the vertical books. A sample arrangement of the books is depicted in the figure.<br><img src="https://espresso.codeforces.com/343ded9fa106a8a70028e480d8dcf8721cf19f03.png" alt="Alt"><br>Help Shaass to find the minimum total thickness of the vertical books that we can achieve.<br><strong>Input</strong><br>The first line of the input contains an integer $n$, $(1 ≤ n ≤ 100)$. Each of the next $n$ lines contains two integers $t_i$ and $w_i$ denoting the thickness and width of the $i$-th book correspondingly, $(1 ≤ ti ≤ 2, 1 ≤ wi ≤ 100)$.<br><strong>Output</strong><br>On the only line of the output print the minimum total thickness of the vertical books that we can achieve.</p>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 12</span><br><span class="line">1 3</span><br><span class="line">2 15</span><br><span class="line">2 5</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 10</span><br><span class="line">2 1</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定n本书的厚度和宽度，选一些竖着放，其他的横着放，但是要保证横着放的书的总宽度不大于竖着放的书的总厚度，求竖着放着的书最小总厚度</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>先假设每一本书都竖着，将这个问题看成<strong>01背包问题</strong>，每一本书视为一个货物，厚度与宽度的和视为体积，厚度视为价值，初始的总厚度视为背包容积，把一本书从竖着变成横着视为选择了这个货物，走一遍背包问题得到最大可以减少的厚度</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,sum=<span class="number">0</span>,dp[<span class="number">205</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    pii a[<span class="number">105</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;</span><br><span class="line">        a[i].second+=a[i].first;</span><br><span class="line">        sum+=a[i].first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=sum;j&gt;=a[i].second;j--)</span><br><span class="line">            dp[j]=dp[j]&gt;dp[j-a[i].second]+a[i].first?dp[j]:dp[j-a[i].second]+a[i].first;</span><br><span class="line">    cout &lt;&lt; sum - dp[sum];</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-思维构造专题</title>
    <url>/categories/CPP/ACM/%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD-%E6%80%9D%E7%BB%B4%E6%9E%84%E9%80%A0%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>专题名为Violence Art，但实际上是考验选手思维的能力，题目的数据范围都不大，但是需要思考如何枚举所有情况，需要构造能力。毕竟真的完全暴力别说5000的数据范围，100的数据范围都得t，$O(n!)$级别复杂度谁顶得住啊。<br><a href="https://codeforces.com/group/5FquYr3Pbe/contest/289144">测验传送门</a></p>
<span id="more"></span>
<h1 id="题目选集"><a href="#题目选集" class="headerlink" title="题目选集"></a>题目选集</h1><h2 id="A-Travelling-Salesman-and-Special-Numbers"><a href="#A-Travelling-Salesman-and-Special-Numbers" class="headerlink" title="A. Travelling Salesman and Special Numbers"></a>A. Travelling Salesman and Special Numbers</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>The Travelling Salesman spends a lot of time travelling so he tends to get bored. To pass time, he likes to perform operations on numbers. One such operation is to take a positive integer $x$ and reduce it to the number of bits set to $1$ in the binary representation of $x$. For example for number $13$ it’s true that $13_{10} = 1101_2$, so it has 3 bits set and $13$ will be reduced to $3$ in one operation.<br>He calls a number special if the minimum number of operations to reduce it to $1$ is $k$.<br>He wants to find out how many special numbers exist which are not greater than $n$. Please help the Travelling Salesman, as he is about to reach his destination!<br>Since the answer can be large, output it modulo $10^9 + 7$.<br><strong>Input</strong><br>The first line contains integer $n (1 ≤ n &lt; 2^{1000})$.<br>The second line contains integer $k (0 ≤ k ≤ 1000)$.<br>Note that $n$ is given in its binary representation without any leading zeros.<br><strong>Output</strong><br>Output a single integer — the number of special numbers not greater than $n$, modulo $10^9 + 7$.</p>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">110</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">111111011</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">169</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong><br>In the first sample, the three special numbers are $3$, $5$ and $6$. They get reduced to $2$ in one operation (since there are two set bits in each of $3$, $5$ and $6$) and then to $1$ in one more operation (since there is only one set bit in $2$).</p>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一个1000位以内的二进制数，假设有a个1，将这个数变为十进制的a再转成二进制视为一次操作，求不大于n且能<strong>恰好</strong>通过k次操作将其变为1的数有多少</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>2的1000次方约为10的300次方，直接暴力穷举每个数显然是不现实的，但注意到<strong>任何一个有a个位为1的数都可以视为等价的</strong>，毕竟经过一次操作后都变成了a，那么先列举好有1000以内个1的每种情况需要多少次操作，再根据组合数知识算一下不大于n的数中，有不同个1位的数各有多少就可以了。<br>但发现求有x个1且小于n的数也并不能直接组合数公式得出，则从最高位开始往下遍历，计算从第i位开始比n小的所有数中，有各个数量的1各有多少个，即以下部分</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=s.<span class="built_in">size</span>()-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[num+j]+=<span class="built_in">c</span>(s.<span class="built_in">size</span>()-i,j);<span class="comment">//这一位前面有num个1，这一位后面有j个1</span></span><br><span class="line">                a[num+j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>比1小那只能是那一位为0，而且但不可能比0小，所以直接跳过为0的位<br>还有一个特殊值’1’，1只需要0次运算，所以当k为1的时候答案要减一，当k为0的时候答案不为0而是1</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod=<span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> ans[<span class="number">1005</span>],a[<span class="number">1005</span>],cmb[<span class="number">1005</span>][<span class="number">1005</span>];<span class="comment">//ans[i]表示有i个1的数需要多少次操作，a[i]表示小与n的数中有a[i]个数有i个1，cmb用来记录组合数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">c</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><span class="comment">//采用记忆化dp的方法算组合数，避免多余运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cmb[n][m])<span class="keyword">return</span> cmb[n][m];</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span>(!m||n==m)res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> res = <span class="built_in">c</span>(n<span class="number">-1</span>,m<span class="number">-1</span>)%mod+<span class="built_in">c</span>(n<span class="number">-1</span>,m)%mod;</span><br><span class="line">    cmb[n][m]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans[n])<span class="keyword">return</span> ans[n];</span><br><span class="line">    <span class="keyword">int</span> m=n,sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)sum++;</span><br><span class="line">        n/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[m]=<span class="built_in">f</span>(sum)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans[m];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    ans[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    string s;</span><br><span class="line">	<span class="keyword">int</span> k,num=<span class="number">0</span>;</span><br><span class="line">	cin &gt;&gt; s &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=s.<span class="built_in">size</span>()-i;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                a[num+j]+=<span class="built_in">c</span>(s.<span class="built_in">size</span>()-i,j);</span><br><span class="line">                a[num+j]%=mod;</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[num]++;</span><br><span class="line">    <span class="keyword">int</span> res = k==<span class="number">0</span>?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">f</span>(i)==k)</span><br><span class="line">        &#123;</span><br><span class="line">            res+=a[i];</span><br><span class="line">            res%=mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)res--;</span><br><span class="line">	cout &lt;&lt; res &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="F-Full-Binary-Tree-Queries"><a href="#F-Full-Binary-Tree-Queries" class="headerlink" title="F. Full Binary Tree Queries"></a>F. Full Binary Tree Queries</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 4 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You have a full binary tree having infinite levels.<br>Each node has an initial value. If a node has value $x$, then its left child has value $2·x$ and its right child has value $2·x + 1$.<br>The value of the root is 1.<br>You need to answer $Q$ queries.<br>There are 3 types of queries:<br>Cyclically shift the <strong>values</strong> of all nodes on the same level as node with value $X$ by $K$ units. (The values/nodes of any other level are not affected).<br>Cyclically shift the <strong>nodes</strong> on the same level as node with value $X$ by $K$ units. (The subtrees of these nodes will move along with them).<br>Print the value of every node encountered on the simple path from the node with value $X$ to the root.<br>Positive $K$ implies right cyclic shift and negative $K$ implies left cyclic shift.<br>It is guaranteed that atleast one type 3 query is present.<br><strong>Input</strong><br>The first line contains a single integer $Q\ (1 ≤ Q ≤ 10^5)$.<br>Then $Q$ queries follow, one per line:</p>
<ul>
<li>Queries of type 1 and 2 have the following format: $T$ $X$ $K$ $(1 ≤ T ≤ 2; 1 ≤ X ≤ 10^{18}; 0 ≤ |K| ≤ 10^{18})$, where $T$ is type of the query.</li>
<li>Queries of type 3 have the following format: $3$ $X$ $(1 ≤ X ≤ 10^{18})$.</li>
</ul>
<p><strong>Output</strong><br>For each query of type 3, print the values of all nodes encountered in descending order.</p>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 12</span><br><span class="line">1 2 1</span><br><span class="line">3 12</span><br><span class="line">2 4 -1</span><br><span class="line">3 8</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12 6 3 1</span><br><span class="line">12 6 2 1</span><br><span class="line">8 4 2 1</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">3 14</span><br><span class="line">1 5 -3</span><br><span class="line">3 14</span><br><span class="line">1 3 1</span><br><span class="line">3 14</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14 7 3 1</span><br><span class="line">14 6 3 1</span><br><span class="line">14 6 2 1</span><br></pre></td></tr></table></figure>
<p><strong>Note</strong><br>Following are the images of the first 4 levels of the tree in the first test case:<br>Original:<img src="https://espresso.codeforces.com/9bc9b00a4be0824f3ab3a052f7c55ae5ad4a1bae.png" alt="Alt"><br>After query 1 2 1:<img src="https://espresso.codeforces.com/c525b5916b994c6630d3d0abf7d051fdd9421292.png" alt="Alt"><br>After query 2 4 -1:<img src="https://espresso.codeforces.com/5954801d203dc3c0c4bf27e9bf96656f9946792b.png" alt="Alt"></p>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一棵无限大的<strong>满二叉树</strong>，有Q个询问（操作），1是让x所在的那一排的值右移k格，2是让x所在那一排的节点右移k格（就是带着子树一起移动），3是从x出发向根节点遍历，输出遇到的所有节点的值</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>用一个数组记录每一排目前右移了多少格，第0排是根节点1，第1排是2、3。</p>
<ul>
<li>当遇到操作2，记录好x的那一排右移了k格后（注意<strong>取模</strong>，后面也是，第$i$排对$2^i$取模），从下一排直到62排（最大只需要考虑$2^{62}$，写到63次方会溢出的），每往下一排位移的格数为上一排的两倍。画个图可以看出，如果节点2向右位移一格，节点4需要移动两格，节点8需要移动四格，得出规律。</li>
<li>当遇到操作1，相对于操作2，不需要考虑之后的节点的位移，只需记录x那一排的位移即可</li>
<li>当遇到操作3，根据每一行记录过的移动的格子数，逐行求解<br>好像即使是对long long进行32位以上的左移操作也不行，没时间想怎么处理，直接记录2的前62次幂的值来用。<br>特别注意：<strong>当x特别大的时候，那一排的节点总数会特别大，直接相乘取模依然会溢出</strong>，所以要用一个<strong>分治策略</strong>来乘（<strong>快速乘</strong>函数q_mul）<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> bin[<span class="number">63</span>];<span class="comment">//存每一排向右位移了多少格</span></span><br><span class="line"><span class="keyword">int</span> tmp[<span class="number">63</span>];<span class="comment">//临时存一下2的幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">power</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(tmp[n])<span class="keyword">return</span> tmp[n];</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        res*=<span class="number">2</span>;</span><br><span class="line">    tmp[n]=res;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">q_mul</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>)<span class="comment">//如果b的二进制末尾是零</span></span><br><span class="line">        &#123;</span><br><span class="line">            (sum += a)%=p;<span class="comment">//a要加上取余</span></span><br><span class="line">        &#125;</span><br><span class="line">        (a &lt;&lt;= <span class="number">1</span>)%=p;<span class="comment">//不断把a乘2相当于提高位数</span></span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;<span class="comment">//把b右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> q;</span><br><span class="line">	cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;<span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,k,l=<span class="number">-1</span>;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; k;</span><br><span class="line">            <span class="keyword">while</span>(x)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                x/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            bin[l]+=k%(<span class="built_in">power</span>(l));</span><br><span class="line">            bin[l]%=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(bin[l]&lt;<span class="number">0</span>)bin[l]+=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">if</span>(t==<span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i+l&lt;<span class="number">63</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    bin[i+l]+=<span class="built_in">q_mul</span>(k,<span class="built_in">power</span>(i),<span class="built_in">power</span>(i+l));</span><br><span class="line">                    bin[i+l]%=<span class="built_in">power</span>(i+l);</span><br><span class="line">                    <span class="keyword">if</span>(bin[i+l]&lt;<span class="number">0</span>)bin[i+l]+=<span class="built_in">power</span>(i+l);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x,y,l=<span class="number">-1</span>;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            cout &lt;&lt; x &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            y=x;</span><br><span class="line">            <span class="keyword">while</span>(y)</span><br><span class="line">            &#123;</span><br><span class="line">                l++;</span><br><span class="line">                y/=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            y=x-(<span class="built_in">power</span>(l));</span><br><span class="line">            y+=bin[l];</span><br><span class="line">            y%=<span class="built_in">power</span>(l);</span><br><span class="line">            <span class="keyword">while</span>(l)</span><br><span class="line">            &#123;</span><br><span class="line">                y/=<span class="number">2</span>;</span><br><span class="line">                l--;</span><br><span class="line">                y-=bin[l];</span><br><span class="line">                <span class="keyword">if</span>(y&lt;<span class="number">0</span>)y+=<span class="built_in">power</span>(l);</span><br><span class="line">                cout &lt;&lt; (<span class="built_in">power</span>(l))+y &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                y+=bin[l];</span><br><span class="line">                y%=<span class="built_in">power</span>(l);</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	cout &lt;&lt; flush;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>暴力</tag>
        <tag>枚举</tag>
        <tag>思维</tag>
        <tag>构造</tag>
      </tags>
  </entry>
  <entry>
    <title>暑期集训-数据结构专题</title>
    <url>/categories/CPP/ACM/%E6%9A%91%E6%9C%9F%E9%9B%86%E8%AE%AD-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>数据结构学的还行，起码比起别的东西是这样的，再接再厉<br><a href="https://codeforces.com/group/5FquYr3Pbe/contest/288107">测验传送门</a></p>
<span id="more"></span>
<h1 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h1><h2 id="A-Cells-Not-Under-Attack"><a href="#A-Cells-Not-Under-Attack" class="headerlink" title="A. Cells Not Under Attack"></a>A. Cells Not Under Attack</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>Vasya has the square chessboard of size $n × n$ and $m$ rooks. Initially the chessboard is empty. Vasya will consequently put the rooks on the board one after another.<br>The cell of the field is under rook’s attack, if there is at least one rook located in the same row or in the same column with this cell. If there is a rook located in the cell, this cell is also under attack.<br>You are given the positions of the board where Vasya will put rooks. For each rook you have to determine the number of cells which are not under attack after Vasya puts it on the board.<br><strong>Input</strong><br>The first line of the input contains two integers $n$ and $m$ $(1 ≤ n ≤ 100 000, 1 ≤ m ≤ min(100 000, n^2))$ — the size of the board and the number of rooks.<br>Each of the next m lines contains integers $x_i$ and $y_i$ $(1 ≤ x_i, y_i ≤ n)$ — the number of the row and the number of the column where Vasya will put the $i$-th rook. Vasya puts rooks on the board in the order they appear in the input. It is guaranteed that any cell will contain no more than one rook.<br><strong>Output</strong><br>Print $m$ integer, the $i$-th of them should be equal to the number of cells that are not under attack after first $i$ rooks are put.</p>
</blockquote>
<h3 id="测试样例"><a href="#测试样例" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">1 1</span><br><span class="line">3 1</span><br><span class="line">2 2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 0</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 2</span><br><span class="line">1 5</span><br><span class="line">5 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">16 9</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">100000 1</span><br><span class="line">300 400</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">9999800001</span><br></pre></td></tr></table></figure>
<h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>向n*n的棋盘放置m颗棋子，与一个棋子同行或同列的格子视为被攻击。<br>每放置一颗棋子后，输出未受攻击的格子数量</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>最后所有未受攻击的格子可以通过平移再组成一个大矩形，只需要用数组r和c记录哪些行和列受到了攻击，将未受攻击的行数和列数相乘就是答案</p>
<h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">bool</span> r[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> a=n,b=n;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        <span class="keyword">if</span>(!r[x])</span><br><span class="line">        &#123;</span><br><span class="line">            r[x]=<span class="number">1</span>;a--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!c[y])</span><br><span class="line">        &#123;</span><br><span class="line">            c[y]=<span class="number">1</span>;b--;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; a * b &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-Minimum-Array"><a href="#C-Minimum-Array" class="headerlink" title="C. Minimum Array"></a>C. Minimum Array</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are given two arrays a and b, both of length n. All elements of both arrays are from 0 to $n−1$.<br>You can reorder elements of the array b (if you want, you may leave the order of elements as it is). After that, let array c be the array of length n, the i-th element of this array is $c_i=(a_i+b_i) % n $ , where $ x % y$ is x modulo y.<br>Your task is to reorder elements of the array b to obtain the <strong>lexicographically</strong> minimum possible array c.<br>Array x of length n is lexicographically less than array y of length n, if there exists such $i$ $(1≤i≤n)$, that $x_i&lt;y_i$, and for any $j$ $(1≤j&lt;i)$ $x_j=y_j$.<br><strong>Input</strong><br>The first line of the input contains one integer $n$ $(1≤n≤2⋅10^5)$ — the number of elements in a, b and c.<br>The second line of the input contains n integers $a_1,a_2,…,a_n (0≤a_i&lt;n)$, where $a_i$ is the $i$-th element of $a$.<br>The third line of the input contains n integers $b_1,b_2,…,b_n (0≤b_i&lt;n)$, where $b_i$ is the $i$-th element of $b$.<br><strong>Output</strong><br>Print the <strong>lexicographically</strong> minimum possible array c. Recall that your task is to reorder elements of the array b and obtain the <strong>lexicographically</strong> minimum possible array c, where the $i$-th element of $c$ is $c_i=(a_i+b_i)%n$.</p>
</blockquote>
<h3 id="测试样例-1"><a href="#测试样例-1" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">0 1 2 1</span><br><span class="line">3 2 1 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 0 0 2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">2 5 1 5 3 4 3</span><br><span class="line">2 4 3 5 6 5 1</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 1 0 2 4</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-1"><a href="#题目大意-1" class="headerlink" title="题目大意"></a>题目大意</h3><p>就给定a,b，b可以随意排序，c是a和b对应位置相加后模n，求如何排序b让c的字典序最小。</p>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>贪心算法</strong>嘛，挺简单的，先给b排个序，每一步找最优解，从头开始，能找到n-a<del>i</del>就用，找不到就用比n-a<del>i</del>大且最小的值，没有更大的就用最小的。</p>
<h3 id="AC代码-1"><a href="#AC代码-1" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],c[maxn];</span><br><span class="line">multiset&lt;<span class="keyword">int</span>&gt;b;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    	cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">int</span> tmp;</span><br><span class="line">    	cin &gt;&gt; tmp;</span><br><span class="line">    	b.<span class="built_in">insert</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        multiset&lt;<span class="keyword">int</span>&gt;::iterator iter=b.<span class="built_in">lower_bound</span>(n-a[i]);</span><br><span class="line">	    <span class="keyword">if</span>(iter==b.<span class="built_in">end</span>())</span><br><span class="line">	    &#123;</span><br><span class="line">	    	c[i]=a[i]+*b.<span class="built_in">begin</span>();</span><br><span class="line">	    	b.<span class="built_in">erase</span>(b.<span class="built_in">begin</span>());</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">else</span> <span class="keyword">if</span>(*iter==n-a[i]) b.<span class="built_in">erase</span>(iter);</span><br><span class="line">	    <span class="keyword">else</span></span><br><span class="line">	    &#123;</span><br><span class="line">	    	c[i]=a[i]+*iter-n;</span><br><span class="line">	    	b.<span class="built_in">erase</span>(iter);</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="H-Subsegments"><a href="#H-Subsegments" class="headerlink" title="H. Subsegments"></a>H. Subsegments</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>Programmer Sasha has recently begun to study data structures. His coach Stas told him to solve the problem of finding a minimum on the segment of the array in $O(log\ n)$, which Sasha coped with. For Sasha not to think that he had learned all, Stas gave him a new task. For each segment of the fixed length Sasha must find the maximum element of those that occur on the given segment exactly once. Help Sasha solve this problem.<br><strong>Input</strong><br>The first line contains two positive integers n and k $(1 ≤ n ≤ 10^5, 1 ≤ k ≤ n) $— the number of array elements and the length of the segment.<br>Then follow n lines: the i-th one contains a single number $a_i ( - 10^9 ≤ a_i ≤ 10^9)$.<br><strong>Output</strong><br>Print n–k + 1 numbers, one per line: on the i-th line print of the maximum number of those numbers from the subarray $a_i\ ,a_i+1\ …\ a_i+k-1$ that occur in this subarray exactly 1 time. If there are no such numbers in this subarray, print “Nothing”.</p>
</blockquote>
<h3 id="测试样例-2"><a href="#测试样例-2" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6 4</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">Nothing</span><br><span class="line">3</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-2"><a href="#题目大意-2" class="headerlink" title="题目大意"></a>题目大意</h3><p>就是一个滑动窗口，先取前k个数，找出只出现一次且最大的数，然后窗口向右移动一格再找，如此反复</p>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>运用<strong>单调队列</strong>的话不太好找只出现一次的数，干脆直接无脑set和map得了，用这两个挺简单就过了</p>
<h3 id="AC代码-2"><a href="#AC代码-2" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">set&lt;<span class="keyword">int</span>&gt;s;</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        q.<span class="built_in">push</span>(temp);</span><br><span class="line">        map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::iterator iter=m.<span class="built_in">find</span>(temp);</span><br><span class="line">        <span class="keyword">if</span>(iter==m.<span class="built_in">end</span>())&#123;m[temp]=<span class="number">1</span>;s.<span class="built_in">insert</span>(temp);&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(iter-&gt;second==<span class="number">1</span>)&#123;m[temp]++;s.<span class="built_in">erase</span>(temp);&#125;</span><br><span class="line">        <span class="keyword">else</span> m[temp]++;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[q.<span class="built_in">front</span>()]==<span class="number">1</span>)&#123;m.<span class="built_in">erase</span>(q.<span class="built_in">front</span>());s.<span class="built_in">erase</span>(q.<span class="built_in">front</span>());&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[q.<span class="built_in">front</span>()]== <span class="number">2</span>)&#123;m[q.<span class="built_in">front</span>()]--;s.<span class="built_in">insert</span>(q.<span class="built_in">front</span>());&#125;</span><br><span class="line">            <span class="keyword">else</span> m[q.<span class="built_in">front</span>()]--;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.<span class="built_in">size</span>()&gt;=k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())cout &lt;&lt; *--s.<span class="built_in">end</span>() &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Nothing&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="I-Little-Girl-and-Maximum-Sum"><a href="#I-Little-Girl-and-Maximum-Sum" class="headerlink" title="I. Little Girl and Maximum Sum"></a>I. Little Girl and Maximum Sum</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>The little girl loves the problems on array queries very much.<br>One day she came across a rather well-known problem: you’ve got an array of n elements (the elements of the array are indexed starting from 1); also, there are q queries, each one is defined by a pair of integers $l_i, r_i (1 ≤ l_i ≤ r_i ≤ n)$. You need to find for each query the sum of elements of the array with indexes from li to $r_i$, inclusive.<br>The little girl found the problem rather boring. She decided to reorder the array elements before replying to the queries in a way that makes the sum of query replies maximum possible. Your task is to find the value of this maximum sum.<br><strong>Input</strong><br>The first line contains two space-separated integers $n (1 ≤ n ≤ 2·10^5)$ and $q (1 ≤ q ≤ 2·10^5)$ — the number of elements in the array and the number of queries, correspondingly.<br>The next line contains n space-separated integers $ai (1 ≤ a_i ≤ 2·10^5)$ — the array elements.<br>Each of the following q lines contains two space-separated integers $l_i$ and $r_i$ $(1 ≤ l_i ≤ r_i ≤ n)$ — the $i$-th query.<br><strong>Output</strong><br>In a single line print a single integer — the maximum sum of query replies after the array elements are reordered.</p>
</blockquote>
<h3 id="测试样例-3"><a href="#测试样例-3" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">5 3 2</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 3</span><br><span class="line">5 2 4 1 3</span><br><span class="line">1 5</span><br><span class="line">2 3</span><br><span class="line">2 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">33</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-3"><a href="#题目大意-3" class="headerlink" title="题目大意"></a>题目大意</h3><p>给一个数组，接下来每次操作对第l到r个数求和，问如何排序数组让最后求和后总和最大</p>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>非常简单的题，用<strong>前缀和</strong>和<strong>差分</strong>思想，得出每一位被加了多少次，然后把最大的数分配给被加了最多次的数，其余位置同理</p>
<h3 id="AC代码-3"><a href="#AC代码-3" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],b[maxn],c[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n ,q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cin &gt;&gt; c[i];</span><br><span class="line">    <span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l,r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        b[l]++;</span><br><span class="line">        b[r+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        a[i]=b[i]+a[i<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        ans+=a[i]*c[i];</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="K-Queries-about-less-or-equal-elements"><a href="#K-Queries-about-less-or-equal-elements" class="headerlink" title="K. Queries about less or equal elements"></a>K. Queries about less or equal elements</h2><h3 id="题面-4"><a href="#题面-4" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are given two arrays of integers $a$ and $b$. For each element of the second array $b_j$ you should find the number of elements in array $a$ that are less than or equal to the value $b_j$.<br><strong>Input</strong><br>The first line contains two integers $n, m (1 ≤ n, m ≤ 2·10^5)$ — the sizes of arrays $a$ and $b$.<br>The second line contains $n$ integers — the elements of array $a ( -10^9 ≤ a_i ≤ 10^9)$.<br>The third line contains $m$ integers — the elements of array $b ( -10^9 ≤ b_j ≤ 10^9)$.<br><strong>Output</strong><br>Print $m$ integers, separated by spaces: the $j$-th of which is equal to the number of such elements in array $a$ that are less than or equal to the value $b_j$.</p>
</blockquote>
<h3 id="测试样例-4"><a href="#测试样例-4" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 3 5 7 9</span><br><span class="line">6 4 2 8</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2 1 4</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 1 2 5</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 2 4 2 5</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-4"><a href="#题目大意-4" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定数组a和b，对b的每个值找出a中有多少数小与等于该值</p>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>非常简单的题，先对a和b排序，然后运用<strong>双指针</strong>很快能做出</p>
<h3 id="AC代码-4"><a href="#AC代码-4" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn],c[maxn];</span><br><span class="line">pii b[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        cin &gt;&gt; temp;</span><br><span class="line">        b[i]=&#123;temp,i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+n);<span class="built_in">sort</span>(b,b+m);</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=b[j].first)&#123;ans++;i++;&#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;c[b[j].second]=ans;j++;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;m)</span><br><span class="line">    &#123;</span><br><span class="line">        c[b[j].second]=ans;j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">        cout &lt;&lt; c[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Hard"><a href="#Hard" class="headerlink" title="Hard"></a>Hard</h1><h2 id="B-Too-Easy-Problems"><a href="#B-Too-Easy-Problems" class="headerlink" title="B. Too Easy Problems"></a>B. Too Easy Problems</h2><h3 id="题面-5"><a href="#题面-5" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 2 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>You are preparing for an exam on scheduling theory. The exam will last for exactly T milliseconds and will consist of n problems. You can either solve problem  $i$  in exactly $t_i$ milliseconds or ignore it and spend no time. You don’t need time to rest after solving a problem, either.<br>Unfortunately, your teacher considers some of the problems too easy for you. Thus, he assigned an integer ai to every problem $i$ meaning that the problem $i$ can bring you a point to the final score only in case you have solved no more than ai problems overall (including problem $i$ ).<br>Formally, suppose you solve problems $p_1, p_2, …, p_k$ during the exam. Then, your final score s will be equal to the number of values of j between 1 and k such that $      k ≤ a_{p_j}$.<br>You have guessed that the real first problem of the exam is already in front of you. Therefore, you want to choose a set of problems to solve during the exam maximizing your final score in advance. Don’t forget that the exam is limited in time, and you must have enough time to solve all chosen problems. If there exist different sets of problems leading to the maximum final score, any of them will do.<br><strong>Input</strong><br>The first line contains two integers n and T ($1 ≤ n ≤ 2·10^5; 1 ≤ T ≤ 10^9$) — the number of problems in the exam and the length of the exam in milliseconds, respectively.<br>Each of the next n lines contains two integers ai and ti ($1 ≤ a_i ≤ n; 1 ≤ t_i ≤ 10^4$). The problems are numbered from 1 to $n$.<br><strong>Output</strong><br>In the first line, output a single integer s — your maximum possible final score.<br>In the second line, output a single integer $k$ $(0 ≤ k ≤ n)$ — the number of problems you should solve.<br>In the third line, output k distinct integers $p_1, p_2, …, p_k (1 ≤ p_i ≤ n)$ — the indexes of problems you should solve, in any order.<br>If there are several optimal sets of problems, you may output any of them.</p>
</blockquote>
<h3 id="测试样例-5"><a href="#测试样例-5" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5 300</span><br><span class="line">3 100</span><br><span class="line">4 150</span><br><span class="line">4 80</span><br><span class="line">2 90</span><br><span class="line">2 300</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">3 1 4</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 100</span><br><span class="line">1 787</span><br><span class="line">2 788</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 100</span><br><span class="line">2 42</span><br><span class="line">2 58</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-5"><a href="#题目大意-5" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定题目数量n和考试时间T，做出每个题目需要的时间，还有题目的一个属性a。一开始没看懂这个a是什么意思，琢磨了一下样例发现是如果做出的总题目数超过a则这个题不给分，就是说a越小题目越简单，你做出了很多题这个题就不该得分（对dalao来说太简单了，但是对菜鸡还是得捞，得给分）。求最多能得到的分，最多能做出多少题，做出来的题目的题号。</p>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p>这个题需要用到<strong>单调队列</strong>的思想，以a的值作为判断某个题的<strong>生存能力</strong>的大小，a更大的题，是更可能得分的题。先将所有题目的a值，编号，耗时记录下来，按照耗时大小排升序。先考虑最高得分，排完序一个题一个题读进单调队列（以a值为关键词升序排列）。<br>假设当前队列里有x个题，如果读到的题a &lt; x，那么做这道题无法得分；<br>如果a = x，那么做这个题之后就a &lt; x了，要么舍弃这个题要么舍弃队首，但显然队首题目的a小与等于读进这个题目前的x，而且耗时还要更少，所以不做；<br>如果a &gt; x，做完可以加分，没问题，但是要考虑做题总数增加后队首题目是否还能有效给分，若队首不再合法，则又舍弃。<br>得到最高分后把选中的题目全部记录下来，从耗时最少的题目开始再遍历一遍，把多余的时间尽量做多的题目，得到最后答案<br><strong>注意：</strong> 得出最高得分后，最多完成的题目不可以超过队首的a值，如果多完成了题目，那么本来得分的题目又不得分了。</p>
<h3 id="AC代码-5"><a href="#AC代码-5" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">2e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">p</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a,i,m;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> p&amp; a) <span class="keyword">const</span><span class="comment">//定义排序方式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>-&gt;a==a.a)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m==a.m)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> i &gt; a.i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> m &gt; a.m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;a &gt; a.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(p a,p b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.m&lt;b.m;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;p&gt;pq;</span><br><span class="line">p temp[maxn];</span><br><span class="line"><span class="keyword">bool</span> ans[maxn];</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,t;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//读入每道题的编号i 时间m 属性a</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,m;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; m;</span><br><span class="line">        temp[i]=&#123;a,i,m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(temp+<span class="number">1</span>,temp+<span class="number">1</span>+n,cmp);<span class="comment">//以m为关键词排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;temp[i].m)<span class="keyword">break</span>;<span class="comment">//时间不够用了直接结束</span></span><br><span class="line">        <span class="keyword">if</span>(temp[i].a&gt;pq.<span class="built_in">size</span>())<span class="comment">//生存能力高的进队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(temp[i]);</span><br><span class="line">            t-=temp[i].m;</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">top</span>().a&lt;pq.<span class="built_in">size</span>())<span class="comment">//淘汰队首生存能力差的</span></span><br><span class="line">            &#123;</span><br><span class="line">                t+=pq.<span class="built_in">top</span>().m;</span><br><span class="line">                pq.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum=pq.<span class="built_in">size</span>();<span class="comment">//最高得分</span></span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line">    <span class="keyword">while</span>(!pq.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        ans[pq.<span class="built_in">top</span>().i]=<span class="number">1</span>;<span class="comment">//记录已选题目编号</span></span><br><span class="line">        min=min&lt;pq.<span class="built_in">top</span>().a?min:pq.<span class="built_in">top</span>().a;<span class="comment">//记录最小的a</span></span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;sum&lt;min;i++)<span class="comment">//注意加进来可能会导致原有题目不得分</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(t&lt;temp[i].m)<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(!ans[temp[i].i])</span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            t-=temp[i].m;</span><br><span class="line">            ans[temp[i].i]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(ans[i])cout &lt;&lt; i &lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="E-Interesting-Array"><a href="#E-Interesting-Array" class="headerlink" title="E. Interesting Array"></a>E. Interesting Array</h2><h3 id="题面-6"><a href="#题面-6" class="headerlink" title="题面"></a>题面</h3><blockquote>
<center>Time limit per test: 1 seconds<br/>Memory limit per test: 256 megabytes<br/></center>
</blockquote>
<blockquote>
<p>We’ll call an array of n non-negative integers a[1], a[2], …, a[n] interesting, if it meets m constraints. The i-th of the m constraints consists of three integers $l_i, r_i, q_i (1 ≤ l_i ≤ r_i ≤ n)$ meaning that value  should be equal to $q_i$.<br>Your task is to find any interesting array of n elements or state that such array doesn’t exist.<br>Expression x&amp;y means the bitwise AND of numbers x and y. In programming languages C++, Java and Python this operation is represented as “&amp;”, in Pascal — as “and”.<br><strong>Input</strong><br>The first line contains two integers n, m $(1 ≤ n ≤ 10^5, 1 ≤ m ≤ 10^5)$ — the number of elements in the array and the number of limits.<br>Each of the next m lines contains three integers $l_i, r_i, q_i (1 ≤ l_i ≤ r_i ≤ n, 0 ≤ q_i &lt; 230)$ describing the i-th limit.<br><strong>Output</strong><br>If the interesting array exists, in the first line print “YES” (without the quotes) and in the second line print n integers a[1], a[2], …, a[n] (0 ≤ a[i] &lt; 230) decribing the interesting array. If there are multiple answers, print any of them.<br>If the interesting array doesn’t exist, print “NO” (without the quotes) in the single line.</p>
</blockquote>
<h3 id="测试样例-6"><a href="#测试样例-6" class="headerlink" title="测试样例"></a>测试样例</h3><p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 3 3</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">YES</span><br><span class="line">3 3 3</span><br></pre></td></tr></table></figure>

<p><strong>Input</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3 2</span><br><span class="line">1 3 3</span><br><span class="line">1 3 2</span><br></pre></td></tr></table></figure>
<p><strong>Output</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NO</span><br></pre></td></tr></table></figure>
<h3 id="题目大意-6"><a href="#题目大意-6" class="headerlink" title="题目大意"></a>题目大意</h3><p>找到一个数列，每一个限制要求数列的第l个到第r个数按位与可以得到q。</p>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p>将每一位视作一个独立的部分。<br>先将所有要求与后为0的限制按优先l然后r排好序。<br>用<strong>前缀和</strong>和<strong>差分</strong>思想标记出每一个必须为1的位，若第l到r个数的某一位与运算得到1，则第l到r个数的该位都得为1，用t[l]++,和t[r+1]–来记录，最后前缀和得出必须为1的位。<br>然后，遍历一遍数组验证剩下的位均为0是否满足剩余的限制。</p>
<h3 id="AC代码-6"><a href="#AC代码-6" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1e5</span>+<span class="number">50</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">que</span>//<span class="title">question</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,q;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(que a, que b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.l==b.l)<span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">que b[maxn];<span class="comment">//记录所有限制</span></span><br><span class="line"><span class="keyword">int</span> t[maxn],tt[maxn],a[<span class="number">31</span>][maxn];<span class="comment">//t差分数组，tt前缀和，a记录答案</span></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; b[i].l &gt;&gt; b[i].r &gt;&gt; b[i].q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(b,b+m,cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        queue&lt;pii&gt;p;<span class="comment">//记录要求与后为0的限制</span></span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(t));</span><br><span class="line">        <span class="built_in">memset</span>(t,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tt));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="comment">//处理每一条限制的第i位</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=b[j].l,r=b[j].r;</span><br><span class="line">            <span class="keyword">if</span>(b[j].q&amp;<span class="number">1</span>)&#123;t[l]++;t[r+<span class="number">1</span>]--;&#125;<span class="comment">//要求与后为1用差分数组记录</span></span><br><span class="line">            <span class="keyword">else</span> p.<span class="built_in">push</span>(&#123;l,r&#125;);</span><br><span class="line">            b[j].q&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//标记那些必须为1的位</span></span><br><span class="line">        &#123;</span><br><span class="line">            tt[j]=t[j]+tt[j<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(tt[j])a[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> iter=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!p.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> l=p.<span class="built_in">front</span>().first,r=p.<span class="built_in">front</span>().second;</span><br><span class="line">            <span class="keyword">if</span>(iter&gt;r)&#123;cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;<span class="comment">//超过这条限制要求的区间还没找到可以填0的地方</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(iter&lt;l)iter=l;<span class="comment">//还没到l，中间没有做要求，那我们跳过，相当于默认填0</span></span><br><span class="line">            <span class="keyword">else</span> &#123;p.<span class="built_in">pop</span>();<span class="keyword">continue</span>;&#125;<span class="comment">//iter已经在l和r之间表示l和r种的iter位置已经确定可以填0了，直接跳过</span></span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(iter&gt;r)&#123;cout &lt;&lt; <span class="string">&quot;NO&quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">                <span class="keyword">if</span>(!tt[iter])</span><br><span class="line">                &#123;</span><br><span class="line">                    p.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> iter++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//输出结果</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)</span><br><span class="line">            sum+=a[j][i]&lt;&lt;j;</span><br><span class="line">        cout &lt;&lt; sum &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>CPP</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>codeforces</tag>
      </tags>
  </entry>
</search>
