<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MIT6.S081操作系统实验——Xv6 and Unix utilities</title>
    <url>/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6-S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94Xv6-and-Unix-utilities/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="实验原文"><a href="#实验原文" class="headerlink" title="实验原文"></a>实验原文</h1><p><a href="https://pdos.csail.mit.edu/6.828/2021/labs/util.html">Lab: Xv6 and Unix utilities (mit.edu)</a></p>
<span id="more"></span>

<h1 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h1><p>进入工作文件夹下，输入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -util <span class="comment">#切换到util分支，对应本实验</span></span><br><span class="line">git clean -xfd <span class="comment">#清除无关文件（未追踪的、忽略的文件和文件夹）</span></span><br><span class="line">git checkout -b solveutil <span class="comment">#新建一个solveutil分支，来记录自己的编程过程</span></span><br></pre></td></tr></table></figure>

<h1 id="sleep-easy"><a href="#sleep-easy" class="headerlink" title="sleep (easy)"></a>sleep (easy)</h1><h2 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h2><p>写一个用户程序<em>sleep</em>，调用<em>system call</em>来实现休眠。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ sleep 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><ul>
<li>观察<em>user</em>文件夹下的<em>grep.c</em>等文件来学习命令行参数如何传入程序。</li>
<li>将<em>sleep</em>程序添加进<em>Makefile</em>文件中的<em>UPROGS</em>。（添加完后点击<em>Makefile</em>右上角图标重新加载<em>Makefile</em>项目才能将<em>sleep.c</em>加入索引）</li>
<li>在用户没有给出<em>sleep</em>的参数时打印错误信息。</li>
<li>使用<code>atoi</code>函数将命令行参数由字符串转为整形。</li>
<li>确保<code>main</code>函数调用了<code>exit</code>函数来退出程序。</li>
</ul>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sleep.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: sleep ticks\n&quot;</span>);<span class="comment">//stderr的文件描述符的值为2</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    sleep(ticks);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="pingpong-easy"><a href="#pingpong-easy" class="headerlink" title="pingpong(easy)"></a>pingpong(easy)</h1><h2 id="任务-1"><a href="#任务-1" class="headerlink" title="任务"></a>任务</h2><p>写一个用户程序<em>pingpong</em>，实现两个进程间的数据传递。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><ul>
<li>使用<code>pipe</code>建立管道，关于管道请面向百度学习。<a href="https://blog.csdn.net/qq_35433716/article/details/86171936">Linux系统编程pipe()</a></li>
<li>使用<code>fork</code>创建子进程。</li>
<li>使用<code>read</code>和<code>write</code>对管道进行读和写。</li>
<li>使用<code>getpid</code>获取当前进程的pid。</li>
</ul>
<h2 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//pingpong.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1[<span class="number">2</span>];<span class="comment">//parent-&gt;child</span></span><br><span class="line">    <span class="keyword">int</span> p2[<span class="number">2</span>];<span class="comment">//child-&gt;parent</span></span><br><span class="line">    pipe(p1);</span><br><span class="line">    pipe(p2);</span><br><span class="line">    <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//child</span></span><br><span class="line">        <span class="keyword">char</span> buffer[] = &#123;<span class="string">&#x27;y&#x27;</span>&#125;;</span><br><span class="line">        read(p1[<span class="number">0</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;%d: received ping\n&quot;</span>,getpid());</span><br><span class="line">        write(p2[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//parent</span></span><br><span class="line">    <span class="keyword">char</span> buffer[] = &#123;<span class="string">&#x27;x&#x27;</span>&#125;;</span><br><span class="line">    write(p1[<span class="number">1</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    read(p2[<span class="number">0</span>],buffer,<span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>,<span class="string">&quot;%d: received pong\n&quot;</span>,getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="primes-moderate-hard"><a href="#primes-moderate-hard" class="headerlink" title="primes(moderate/hard)"></a>primes(moderate/hard)</h1><h2 id="任务-2"><a href="#任务-2" class="headerlink" title="任务"></a>任务</h2><p>使用管道写一个并发版本的素数筛来找出2~35中的素数。</p>
<p>相关链接<a href="https://swtch.com/~rsc/thread/">Bell Labs and CSP Threads (swtch.com)</a></p>
<p>概念图：</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/1gfBPmyOSnMvtCl.gif" alt="img"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><ul>
<li><p>请牢记这个题目的要求是<strong>通过多线程来加速素数筛</strong>，在编写程序时要检查自己的程序是否满足并发，<strong>一定不要在父进程写入所有数字后子进程才开始处理！</strong>即使这样也能通过测试。</p>
</li>
<li><p>请小心关闭进程不需要的文件描述符，否则程序将在第一个进程达到 35 之前耗尽xv6的资源。（<strong>及时关闭管道非常重要！！！</strong>）</p>
</li>
<li><p>当一个进程读取完所有数字后，应该等到所有他的子进程终止才能终止，从而避免产生僵尸进程。（善用<code>ctrl+p</code>）</p>
</li>
<li><p>当一个管道的写端被关闭时，对读端进行<code>read</code>会返回0。</p>
</li>
<li><p>写入所有数字后<strong>再写入一个0来表示写入完毕</strong>，否则子进程无法知道父进程是否写入完毕。采取这种做法是因为执行了<code>fork</code>后父进程才关闭管道写端，子进程并不能感应到管道写端已经关闭了。</p>
</li>
</ul>
<h2 id="源码-2"><a href="#源码-2" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//primes.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p1[<span class="number">2</span>];</span><br><span class="line">    pipe(p1);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= <span class="number">35</span>; i++) &#123;</span><br><span class="line">        write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    write(p1[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> n, prime, p2[<span class="number">2</span>];</span><br><span class="line">        pipe(p2);</span><br><span class="line">        read(p1[<span class="number">0</span>], &amp;prime, <span class="keyword">sizeof</span>(prime));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">        <span class="keyword">if</span> (read(p1[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)) &amp;&amp; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//子进程会复制一遍父进程的两个管道，其中父进程用来与祖父进程交流的管道应该被关闭</span></span><br><span class="line">                close(p1[<span class="number">0</span>]);</span><br><span class="line">                close(p1[<span class="number">1</span>]);</span><br><span class="line">                p1[<span class="number">0</span>] = p2[<span class="number">0</span>];</span><br><span class="line">                p1[<span class="number">1</span>] = p2[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n % prime != <span class="number">0</span>)</span><br><span class="line">                    write(p2[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">            &#125; <span class="keyword">while</span> (read(p1[<span class="number">0</span>], &amp;n, <span class="keyword">sizeof</span>(n)) &amp;&amp; n);</span><br><span class="line">            write(p2[<span class="number">1</span>], &amp;n, <span class="keyword">sizeof</span>(n));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭占用的管道</span></span><br><span class="line">        close(p1[<span class="number">0</span>]);</span><br><span class="line">        close(p1[<span class="number">1</span>]);</span><br><span class="line">        close(p2[<span class="number">0</span>]);</span><br><span class="line">        close(p2[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="find-moderate"><a href="#find-moderate" class="headerlink" title="find(moderate)"></a>find(moderate)</h1><h2 id="任务-3"><a href="#任务-3" class="headerlink" title="任务"></a>任务</h2><p>写一个简单版本的UNIX find程序，<code>ls path filename</code>为寻找目录<em>path</em>下所有文件名为<em>filename</em>的文件并输出。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ mkdir a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><ul>
<li>查看<em>user/ls.c</em>中的代码来学习如何读取文件夹。</li>
<li>使用递归来实现遍历所有子目录。</li>
<li>不要递归进入*”.”<em>（即当前目录）和</em>“..”*（即父目录）</li>
<li>请使用<code>strcmp</code>函数而非<code>==</code></li>
</ul>
<h2 id="源码-3"><a href="#源码-3" class="headerlink" title="源码"></a>源码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读取path中的文件名*/</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *</span></span><br><span class="line"><span class="function"><span class="title">filename</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = path;</span><br><span class="line">    <span class="keyword">while</span> (*p)</span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">while</span> (*p != <span class="string">&#x27;/&#x27;</span> &amp;&amp; p != path)</span><br><span class="line">        p--;</span><br><span class="line">    <span class="keyword">return</span> p == path ? p : ++p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span></span></span><br><span class="line"><span class="function"><span class="title">find</span><span class="params">(<span class="keyword">char</span> *path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line">    <span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open %s\n&quot;</span>, path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (st.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> T_FILE:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(filename(path), target) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> T_DIR:</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">            p = buf + <span class="built_in">strlen</span>(buf);</span><br><span class="line">            *p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (de.inum == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) == <span class="number">0</span> || <span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                memmove(p, de.name, DIRSIZ);</span><br><span class="line">                p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line">                find(buf);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;Usage: find path filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    target = argv[<span class="number">2</span>];</span><br><span class="line">    find(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="xargs-moderate"><a href="#xargs-moderate" class="headerlink" title="xargs(moderate)"></a>xargs(moderate)</h1><h2 id="任务-4"><a href="#任务-4" class="headerlink" title="任务"></a>任务</h2><p>写一个简单版本的UNIX xargs程序，从<em>stdin</em>逐行读取，将每一行作为参数执行命令。比如<code>echo hello too | xargs echo bye</code>，要输出<code>bye hello too</code>，等价于<code>echo bye hello too</code>。（建议看原文理解）</p>
<h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><ul>
<li><p>使用<code>gets</code>函数来读取<em>stdin</em>。</p>
</li>
<li><p>使用<code>fork</code>和<code>exec</code>函数来执行子进程。</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//xargs.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">64</span>], *xargs[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">        xargs[i - <span class="number">1</span>] = argv[i];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = argc - <span class="number">1</span>;</span><br><span class="line">        gets(buf, <span class="number">64</span>);</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        xargs[x++] = buf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> *p = buf; *p; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (*p == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                *p = <span class="number">0</span>;</span><br><span class="line">                xargs[x++] = p + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">                *p = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">            exec(argv[<span class="number">1</span>], xargs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    wait(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="评测"><a href="#评测" class="headerlink" title="评测"></a>评测</h1><p>输入<code>make grade</code>或<code>python ./grade-lab-util</code>来评测整个实验。</p>
<p>若想单独评测一个题目比如<em>sleep</em>可以使用<code>python ./grade-lab-util sleep</code>。</p>
<p>评测整个实验前别忘了在xv6根目录创建一个名为<em>time.txt</em>的文件，在里面输入一个整数表明自己在这个实验上花了多少个小时。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MIT6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>MIT6.s081操作系统实验——环境搭建</title>
    <url>/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/MIT6-S081%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E2%80%94%E2%80%94%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在做过各种语言的项目，对网站架构和职业要求有一个基础认知后，我认为要在卷翻天的职场立足，在了解并能使用前沿技术的同时还得打好计算机基础，所以痛下决心重拾大二摸鱼过去的OS实验。</p>
<p>2018年及以前MIT6.828是MIT的本科生OS课程，2019开始这门课被拆成了6.s081和6.828，分别成为本科生和研究生的OS课程。6.s081的实验由原来的5个拆成了10个，总体难度降低，更加易于基础并不牢固的学生学习。</p>
<p>课程链接<a href="https://pdos.csail.mit.edu/6.828/2021/">6.S081 / Fall 2021 (mit.edu)</a></p>
<p>我将记录2021年课程的实验全过程，下文是运行环境以及<strong>调试环境</strong>搭建的记录，着重记录<strong>如何使用CLion进行远程开发以及远程调试</strong>，这在网上很难找到相应资料。（非常佩服能使用原始gdb进行调试的人，已经是一个离不开ide的快速跳转，自动补全，集成调试的废物了）</p>
<span id="more"></span>

<h1 id="安装虚拟机以及必要工具下载"><a href="#安装虚拟机以及必要工具下载" class="headerlink" title="安装虚拟机以及必要工具下载"></a>安装虚拟机以及必要工具下载</h1><p>课程的文档里有各个平台的安装教程，本文以VMware Workstation Pro 16中安装Ubuntu20.04.4 Server作为基础环境。</p>
<p>课程原文 <a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">6.S081 / Fall 2021 (mit.edu)</a></p>
<p>安装虚拟机可以在百度上找到很多教程，这里不再赘述，仅放出下载链接</p>
<ul>
<li><p><a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">下载 VMware Workstation Pro | CN</a></p>
</li>
<li><p><a href="https://cn.ubuntu.com/download/server/step1">获取Ubuntu服务器版 | Ubuntu</a>   我下载的是Server版，只有命令行没有桌面，更喜爱桌面版可以自行下载</p>
</li>
</ul>
<p>安装完成并启动虚拟机后输入以下命令下载必要工具，主要是c/c++编译工具集，riscv64架构的gnu工具集，qemu虚拟机，git，适用于riscv64架构的gdb。（本课程使用的操作系统为xv6，是一个基于riscv64架构的小型教学向OS）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu </span><br></pre></td></tr></table></figure>

<p>直接下载可能会过于缓慢，如果太慢了请先替换apt源为国内源（<strong>请尽量用较新的源</strong>）。这里使用的是阿里源和清华源，网上教程有很多，以下是我使用的源，用它替换掉*/etc/apt/source.list*中的内容后输入<code>apt-get update</code>就行了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#添加阿里源</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment">#添加清华源</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="下载xv6的git仓库"><a href="#下载xv6的git仓库" class="headerlink" title="下载xv6的git仓库"></a>下载xv6的git仓库</h1><p>在用户文件夹下输入以下命令下载课程的xv6源码，注意<strong>不要下载xv6的官方源码而是下载课程改动过的源码</strong>，对改动内容感兴趣的话可以使用<code>git log</code>查看改动内容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://g.csail.mit.edu/xv6-labs-2021</span><br></pre></td></tr></table></figure>

<p>下载速度可能很缓慢，可以直接从我的git仓库fork一份或直接clone。</p>
<p><a href="https://github.com/foliet/MIT-6.s081">foliet/MIT-6.s081 (github.com)</a></p>
<p>我仓库my+实验名的分支是我自己完成后代码，ricsv分支是xv6的源码，其他十个分支是对应lab的分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:Foliet/MIT-6.s081.git <span class="comment">#ssh</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Foliet/MIT-6.s081.git <span class="comment">#https</span></span><br></pre></td></tr></table></figure>

<p>先进入文件夹内，然后输入以下两条命令。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout util</span><br><span class="line">make qemu</span><br></pre></td></tr></table></figure>

<p>看到如下输出即为启动成功，一切顺利，否则按照课程原文说明逐个工具检查是否下载成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">riscv64-unknown-elf-gcc    -c -o kernel/entry.o kernel/entry.S</span><br><span class="line">riscv64-unknown-elf-gcc -Wall -Werror -O -fno-omit-frame-pointer -ggdb -DSOL_UTIL -MD -mcmodel=medany -ffreestanding -fno-common -nostdlib -mno-relax -I. -fno-stack-protector -fno-pie -no-pie   -c -o kernel/start.o kernel/start.c</span><br><span class="line">...  </span><br><span class="line">riscv64-unknown-elf-ld -z max-page-size=4096 -N -e main -Ttext 0 -o user/_zombie user/zombie.o user/ulib.o user/usys.o user/printf.o user/umalloc.o</span><br><span class="line">riscv64-unknown-elf-objdump -S user/_zombie &gt; user/zombie.asm</span><br><span class="line">riscv64-unknown-elf-objdump -t user/_zombie | sed <span class="string">&#x27;1,/SYMBOL TABLE/d; s/ .* / /; /^$/d&#x27;</span> &gt; user/zombie.sym</span><br><span class="line">mkfs/mkfs fs.img README  user/xargstest.sh user/_cat user/_echo user/_forktest user/_grep user/_init user/_kill user/_ln user/_ls user/_mkdir user/_rm user/_sh user/_stressfs user/_usertests user/_grind user/_wc user/_zombie </span><br><span class="line">nmeta 46 (boot, super, <span class="built_in">log</span> blocks 30 inode blocks 13, bitmap blocks 1) blocks 954 total 1000</span><br><span class="line">balloc: first 591 blocks have been allocated</span><br><span class="line">balloc: write bitmap block at sector 45</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0</span><br><span class="line"></span><br><span class="line">xv6 kernel is booting</span><br><span class="line"></span><br><span class="line">hart 2 starting</span><br><span class="line">hart 1 starting</span><br><span class="line">init: starting sh</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<h1 id="配置Ubuntu的ssh服务器"><a href="#配置Ubuntu的ssh服务器" class="headerlink" title="配置Ubuntu的ssh服务器"></a>配置Ubuntu的ssh服务器</h1><p>输入<code>sudo su</code>进入root用户模式，然后输入<code>passwd</code>为root用户设置一个密码。</p>
<p>输入<code>ls /etc/ssh</code>命令查看是否有<em>sshd_config</em>这个文件，如果没有则输入<code>apt-get install openssh-server</code>下载。</p>
<p>将<code>sshd_config</code>中的PermitRootLogin的#号去掉，并将值改为yes。</p>
<p>输入<code>service ssh restart</code>重启ssh服务。（<strong>如果没设置开机自动启动，那么每次开机都要重启ssh服务</strong>）</p>
<p>完成后在物理机上打开一个shell，输入以下命令尝试连接虚拟机。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@&#123;你的虚拟机ip&#125;</span><br><span class="line">ssh root@192.168.126.128 <span class="comment"># 比如这样</span></span><br></pre></td></tr></table></figure>

<p>如果不成功请转向百度找问题，搜索<strong>“以root用户连接ssh服务器”</strong>应该能找到很多教程。</p>
<h1 id="在CLion上连接虚拟机"><a href="#在CLion上连接虚拟机" class="headerlink" title="在CLion上连接虚拟机"></a>在CLion上连接虚拟机</h1><p>CLion是jetbrains公司面向c/c++的ide，<strong>通过学生优惠可以免费获取全家桶的一年通行证，并且在校期间可以无限续，只需要有edu后缀的邮箱就行了</strong>，请转向百度搜索如何获得学生优惠。</p>
<p><a href="https://www.jetbrains.com/zh-cn/clion/">CLion：JetBrains 出品的 C 和 C++ 跨平台 IDE</a></p>
<h2 id="配置工具链"><a href="#配置工具链" class="headerlink" title="配置工具链"></a>配置工具链</h2><p>新建一个项目，打开<strong>设置</strong>，选择<strong>构建、执行、部署</strong>，选择<strong>工具链</strong>，点上方加号➕添加一个远程主机，添加一个ssh凭据并手动输入gdb-multiarch的路径来替代默认gdb（原始gdb不能识别riscv的指令集）。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329105815490.png" alt="image-20220329105815490"></p>
<p>我这里是下了cmake，不下cmake也没关系，只需要管<strong>凭据</strong>和<strong>调试器</strong>。</p>
<h2 id="配置部署服务器"><a href="#配置部署服务器" class="headerlink" title="配置部署服务器"></a>配置部署服务器</h2><p>点击上方<strong>工具</strong>，选择<strong>部署</strong>，点击<strong>配置</strong>，填好映射路径。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329130436272.png" alt="image-20220329130436272"></p>
<p>然后依次点<strong>工具</strong>、<strong>部署</strong>、<strong>浏览远程主机</strong>，就可以管理虚拟机的文件了，在这里可以很方便的直接管理虚拟机文件。</p>
<p>删除项目内初始的文件（如果有的话），右键项目文件夹，点击部署，然后下载虚拟机里的文件。</p>
<h2 id="配置Makefile项目"><a href="#配置Makefile项目" class="headerlink" title="配置Makefile项目"></a>配置Makefile项目</h2><p>打开设置，将构建目标设置为<em>qemu-gdb</em>。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/d3PMj8gnxAlXT6u.png" alt="image-20220402152641258"></p>
<p><strong>如果设置里显示未检测到<em>Makefile</em>项目就删掉项目文件夹里的*.idea*文件夹，然后重新打开项目。</strong>之前的设置会被初始化，需要重新设置一下。</p>
<p>设置完了之后打开<em>Makefile</em>文件，点右上角按钮重新加载项目。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/FXeTWYk2zhjrHGS.png" alt="image-20220402152934792"></p>
<p>此时索引就建立完毕了，可以自动补全和<code>ctrl+B</code>来快速跳转了。</p>
<h2 id="添加调试配置"><a href="#添加调试配置" class="headerlink" title="添加调试配置"></a>添加调试配置</h2><p>在右上角打开<strong>运行/调试配置</strong>，添加一个<strong>远程调试</strong>的配置。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/image-20220329124021990.png" alt="image-20220329124021990"></p>
<p>课程内的gdb服务器默认使用<em>25000</em>端口。</p>
<p>执行<code>make</code>后会对内核程序和和每个用户程序各生成一个符号文件，内核的符号文件就叫<em>kernel</em>，用户程序的符号文件为_{程序名}，例如ls的符号文件为<em>_ls</em>。</p>
<h2 id="设置-gdbinit"><a href="#设置-gdbinit" class="headerlink" title="设置.gdbinit"></a>设置.gdbinit</h2><p>在*/root<em>文件夹下创建一个名为</em>.gdbinit*的文件</p>
<p>向里面填入如下内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> confirm off</span><br><span class="line"><span class="built_in">set</span> architecture riscv:rv64</span><br><span class="line">file kernel/kernel</span><br><span class="line">add-symbol-file user/_ls</span><br><span class="line"><span class="built_in">set</span> disassemble-next-line auto</span><br><span class="line"><span class="built_in">set</span> riscv use-compressed-breakpoints yes</span><br></pre></td></tr></table></figure>

<p>这里是调试<em>ls</em>，如果要调试自己写的程序，比如说<em>myproc</em>，就添加一行<code>add-symbol-file user/_myproc</code>。</p>
<h2 id="启动调试服务器"><a href="#启动调试服务器" class="headerlink" title="启动调试服务器"></a>启动调试服务器</h2><p>在虚拟机的xv6文件夹下输入<code>make qemu-gdb</code>来启动gdb服务器，如遇到错误可以尝试<code>make clean</code>来清除之前make生成的文件，shell输出以下内容即为开启成功。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*** Now run <span class="string">&#x27;gdb&#x27;</span> <span class="keyword">in</span> another window.</span><br><span class="line">qemu-system-riscv64 -machine virt -bios none -kernel kernel/kernel -m 128M -smp 3 -nographic -drive file=fs.img,<span class="keyword">if</span>=none,format=raw,id=x0 -device virtio-blk-device,drive=x0,bus=virtio-mmio-bus.0 -S -gdb tcp::25000</span><br></pre></td></tr></table></figure>

<p>如果显示<em>25000</em>端口已被占用或者文件<em>fs.img</em>被占用，应该是上一次运行没有正确退出，请自行百度查找如何根据占用端口或者文件获取pid，然后kill掉，这里建议使用lsof。</p>
<ul>
<li><code>apt-get install lsof</code>安装lsof。</li>
<li><code>lsof fs.img</code>和<code>lsof -i:25000</code>查询进程。</li>
</ul>
<h2 id="开始调试"><a href="#开始调试" class="headerlink" title="开始调试"></a>开始调试</h2><p>点击CLion右上角调试按钮开始调试ls程序，下方会显示连接成功，然后回到shell会发现可以输入命令了，此时我输入<code>ls grep</code>，成功触发断点。</p>
<p><img src="https://picture-bed-1306010815.file.myqcloud.com/dE2UWb5O3a6RSvo.png" alt="image-20220329131621170"></p>
<h1 id="xv6和CLion相关"><a href="#xv6和CLion相关" class="headerlink" title="xv6和CLion相关"></a>xv6和CLion相关</h1><ul>
<li>xv6没有实现ps程序，要列出当前进程可以在xv6的终端里中输入<code>ctrl+p</code>，关闭xv6先按<code>ctrl+a</code>再按<code>x</code>。</li>
<li>调试xv6时发生读取空指针，缓冲区溢出等错误时CLion不会报错，但是会导致调试异常，当系统中断，跳转到<em>spinlock.c</em>等文件内时需要格外注意。</li>
<li>在CLion内可以用<code>ctrl+alt+h</code>来查看一个函数被哪些函数调用了。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>MIT6.S081</tag>
      </tags>
  </entry>
  <entry>
    <title>数组与指针的深度理解</title>
    <url>/categories/CPP/%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数组存储与指针问题"><a href="#数组存储与指针问题" class="headerlink" title="数组存储与指针问题"></a>数组存储与指针问题</h1><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote>
<p>先定义$A_1$~$A_5$ 五个类型，请填写以下表格</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">Declare</th>
<th align="center">sizeof $A_n$</th>
<th align="center">sizeof *$A_n$</th>
<th align="center">sizeof **$A_n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int $A_1$[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int *$A_2$[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int (*$A_3$)[3][5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int *($A_4$[3][5])</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">int (*$A_5$[3])[5]</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<span id="more"></span>
<h3 id="A-1"><a href="#A-1" class="headerlink" title="$A_1$"></a>$A_1$</h3><p>此为一个普通的二维数组，直接计算其sizeof即为计算其在内存中所占大小，*$A_1$为int [5]即一个长度为5的一维数组，**$A_1$为int即一个普通的int类型的数据。</p>
<p>以下标识了对应的<strong>数据类型</strong>，数据类型的后半部分标识是数组还是指针，前半部分表示数组/指针对应元素的数据类型，在使用Visual Studio的调试功能时可以显示每个变量对应的数据类型</p>
<p>sizeof $A_1$=3*5*4=60   int [3][5]</p>
<p>sizeof *$A_1$=5*4=20  int [5]</p>
<p>sizeof **$A_1$=4  int</p>
<h3 id="A-2"><a href="#A-2" class="headerlink" title="$A_2$"></a>$A_2$</h3><p>$A_2$同时与*和[]相连，[]优先级更高，则其为一个二维数组，数组的每一个元素为int*，即指针数组（装有指针的数组）。</p>
<p>sizeof $A_2$=3*5*8=120  int* [3][5]</p>
<p>sizeof *$A_2$=5*8=40  int* [5]</p>
<p>sizeof **$A_2$=8  int*</p>
<h3 id="A-3"><a href="#A-3" class="headerlink" title="$A_3$"></a>$A_3$</h3><p>$A_3$同时与*和[]相连，但*处打了括号，故*的优先级更高，则其为一个数组指针（指向一个二维数组的指针），以下语句完全是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">5</span>] = *a;</span><br></pre></td></tr></table></figure>

<p><em>$A_3$的大小即是二维数组的大小，</em>*$A_3$即是一维数组的大小。</p>
<p>sizeof $A_3$=8  int[3][5] *</p>
<p>sizeof *$A_3$=3*5*4=60  int [3][5]</p>
<p>sizeof **$A_3$=5*4=20  int [5]</p>
<h3 id="A-4"><a href="#A-4" class="headerlink" title="$A_4$"></a>$A_4$</h3><p>$A_4$同时与*和[]相连，[]本身优先级更高，加上括号性质不变，即情况同$A_2$。</p>
<p>sizeof $A_4$=3*5*8=120</p>
<p>sizeof *$A_4$=5*8=40</p>
<p>sizeof **$A_4$=8</p>
<h3 id="A-5"><a href="#A-5" class="headerlink" title="$A_5$"></a>$A_5$</h3><p>(*$A_5$[3])代表$A_5$是一个长度为3的一维数组，数组的元素是指针，该指针的数据类型为int[5] *。</p>
<p>int[5] *，代表该元素是一个指针指向了长度为5的一维数组，数组中元素的数据类型为int。$A_5$的数据类型为int[5]* [3]。</p>
<p>sizeof $A_5$=3*8=24  int[5]* [3] （长为3的数组装着int[5]*）</p>
<p>sizeo *$A_5$=8  int[5] *</p>
<p>sizeof **$A_5$=5*2=20  int [5]</p>
<p>经过以上的分析后，可得出最终答案为：</p>
<table>
<thead>
<tr>
<th align="center">Declare</th>
<th align="center">sizeof $A_n$</th>
<th align="center">sizeof *$A_n$</th>
<th align="center">sizeof **$A_n$</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int A1[3][5]</td>
<td align="center">60</td>
<td align="center">20</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">int *$A_2$[3][5]</td>
<td align="center">120</td>
<td align="center">40</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">int (*$A_3$)[3][5]</td>
<td align="center">8</td>
<td align="center">60</td>
<td align="center">20</td>
</tr>
<tr>
<td align="center">int *($A_4$[3][5])</td>
<td align="center">120</td>
<td align="center">40</td>
<td align="center">8</td>
</tr>
<tr>
<td align="center">int (*$A_5$[3])[5]</td>
<td align="center">24</td>
<td align="center">8</td>
<td align="center">20</td>
</tr>
</tbody></table>
<p>ps. $A_2$~$A_5$也可能是三维数组，此时一个指针所分配的空间长度不只是一个元素。</p>
<p>如果$A_2$中二维数组装着的int*实际上都是new出来的长16的数组，那么为什么此时sizeof依然不变呢？</p>
<p>对于int *a=new int[16]，a虽然被分配了64个字节大小的空间，但是sizeof并不计算这64个字节，这个a和int b[16]都是一个长16的数组，但是a的数据类型是int *只被看成一个路牌，而b的数据类型是int [16]被sizeof看成整个空间</p>
<h2 id="延申"><a href="#延申" class="headerlink" title="延申"></a>延申</h2><p>int main()函数中其实存在参数，其完整表达形式应为int main(int argc, char **argv)。</p>
<p>当a.cpp编译成a.exe后 可以在命令行里输入参数，例如：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">a.exe -a -s -o</span><br></pre></td></tr></table></figure>

<p>此时这个时候argc是3（3个参数），argv则装着这三个参数。为什么用到了char**呢？这里举个例子：</p>
<p>当定义一个int数组时，需要先定义长度，比如int array[100]，array其中的元素最多为100个，而且即使用不到100个位置，也占用了400byte内存。</p>
<p>如何让使其不定长呢？先int* array = new int[16]，当想扩容时，int* temp = new int[32]，然后for循环把array复制进tmp，再array=tmp，即扩容了一倍。</p>
<p>这种扩容<strong>不是在原来分配的地址上向周围扩容</strong>，而是新开辟一块更大空间并把原来的数据复制过去。</p>
<p>举个例子来说，一个人有一块封地，后来被天子赐予了一块更大的封地，这块封地是在一个任意未开发的位置选取的，而不是在他原来的封地上进行扩容，因为原来的位置周围可能已经被别人占用了。</p>
<p>那么为什么不先int array[16]，再int tmp[32]，for循环后再array=tmp呢？那是因为<strong>数组可以看成const类型的指针</strong>，初始化后就不能再修改他的值也就是指向的地址，而指针可以修改他所指向的地址。以上面的例子来说，数组就是一块预先分配好的固定的封地，而指针分配的封地是可以变的，那么先分配小封地，用满了再分配大封地就是扩容的策略。这也是C++的STL中的vector所使用的策略，vector并不需要预先定义大小，只需要push_back就可以了，当预先分配的空间满载的时候就使用另一块更大的空间，复制原数据并回收原来的空间。</p>
<p>char**用的就是<strong>不定长的性质</strong>来代替定长的二维数组，用以有效利用内存。</p>
<p>注意：int *a=new int[16]和int b[16]中a和b不同，前者是一个指针，导致了这样定义数组可扩容。后者是一个数组，长度是固定的，数组名的值和指针一样也是一个地址。指针和数组都指向一片地址，所以才说二者近似，但直接定义数组的空间是固定的，指针定义数组的空间是可变的，<strong>b是一个const类型的指针</strong>。</p>
<p>同时还有另一种扩容的策略。在STL的deque中除了push_back以外还可以push_front，那么前面这种策略就不适用了。deque先预先分配一段空间，当头插数据到顶端了或者尾插数据到顶端了，deque开辟一块内存在<strong>逻辑上</strong>和原内存前后相连，而vector是<strong>物理上</strong>连续的。deque这样的方式类似于链表，将一块块内存在逻辑上串联起来。</p>
]]></content>
      <categories>
        <category>CPP</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>从Internet设计原则中汲取经验</title>
    <url>/categories/%E8%A7%84%E8%8C%83%E4%B8%8E%E6%A0%87%E5%87%86/%E4%BB%8EInternet%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%AD%E6%B1%B2%E5%8F%96%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="从Internet设计原则中汲取经验"><a href="#从Internet设计原则中汲取经验" class="headerlink" title="从Internet设计原则中汲取经验"></a>从Internet设计原则中汲取经验</h1><p>要深入理解软件工程的概念，就应该从那些经典的工程中学习，寻找共性。 从优秀工程的设计原则中思考，反思自己的项目工作中的设计方式， 回忆那些让开发变得很混乱的问题。<br>从前人总结出的设计原则中和自己的工作对比，找出哪些是自己可以改进的，慢慢学习如何进行工程设计。</p>
<span id="more"></span>

<p>Internet最重要的设计原则包括以下十点</p>
<h2 id="保证工作"><a href="#保证工作" class="headerlink" title="保证工作"></a>保证工作</h2><blockquote>
<p>直到多个原型系统成功地与对方相互通信，方可完成设计或者确定标准。设计者常常首先写出一个1000页的标准，并获得批准，过后才发现存在严重的缺陷，根本无法工作。然后他们再编写一个1.1版本的标准。这不是正确的工作方式。</p>
</blockquote>
<p>在建立标准前应该先测试一下可行性，有的时候我会认为自己的想法非常容易实现，甚至简单到没必要测试，等到了实际开发的时候，特别是在实现那些我认为是细枝末节的地方时，发现这个地方的逻辑有问题，根本不可能实现。</p>
<p>比如说我在设计数据库的表关系时，有order和user两个实体，每个user有很多order。依据数据库设计三大范式，我在order的表里添加了user_id来建立映射关系，这听起来非常正确，所以我在最初以此作为标准进行开发。</p>
<p>根据这个想法我实现了后端的功能，但是当我回到前端开发时，意识到我在前端需要显示每个订单对应的用户的名字。<br>在不改变后端代码的情况下，想要实现这个功能必须向后端发送大量的包来进行查询每个user_id对应的user，再把用户名给读取出来，这显然是效率低下的！</p>
<p>于是我只能选择去重构后端（我前面举的例子是实际问题的简化，实际情况还要再复杂一点），而如果一开始先好好思考可行性并推敲好使用流程就可以避免类似的麻烦。</p>
<p>上述问题在<strong>保证工作</strong>这个原则下的启示是，应该先尝试着将一条order的信息展示出来，再将标准确定下来。即使自己觉得逻辑非常清晰，也应该好好的从头开始捋一捋流程，避免忽略不切实际的设计。</p>
<p>就好像是高中的导数题，拿到题一看迅速的对应上了解题模型，觉得这道题非常简单，等到实际做起来发现好像和不是同一个类型的题。它很像曾经做过的某题，但是解题方法并不一样，而到发现这个问题时只能推倒重做。</p>
<p><strong>这个原则不是要否定那些逻辑并不足够严谨的假设，而是警告设计者不要想当然地认为某些东西应该是对的</strong></p>
<h2 id="保持简单"><a href="#保持简单" class="headerlink" title="保持简单"></a>保持简单</h2><blockquote>
<p>有疑问时应该使用最简单的解决方案。William of Occam在14世纪就提出了这条原则(称为奥卡姆的剃刀)。换成现代术语就是:决斗特性。如果一项特性并非绝对不要，那么就放弃该特性。尤其是，通过组合其他的特性也能够获得同样效果的时候。</p>
</blockquote>
<h2 id="明确选择"><a href="#明确选择" class="headerlink" title="明确选择"></a>明确选择</h2><blockquote>
<p>如果有几种方法可以完成同样的事情，则选择其中一种方法。用两种或者多种方法来做同样的事情简直是自找麻烦。通常标准会有多个选项、多种模式或多个参数，因为多个实力强大的参与方坚持认为他们的方法是最好的。设计者应该坚决抵制这种倾向，学会说“不”。</p>
</blockquote>
<h2 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h2><blockquote>
<p>这条原则直接导致了协议栈的思想，每一层的协议完全独立于所有其他的协议。按照这种方法，如果实际环境中要求改变一个模块或者一层，则其他模块或层都不会受到影响。</p>
</blockquote>
<p>编写代码时一定得注重<strong>”高内聚，低耦合“</strong>，这是有效提升可维护性的手段，试想以下情景：</p>
<ul>
<li><p>你正在编写一个函数，已经写了一百多行，当你逻辑不够清晰时想再重新梳理一遍这个函数，发现自己一时难以重新理顺逻辑。</p>
</li>
<li><p>你需要在两个不同的地方做同样的事情，你为了方便直接复制粘贴再稍微修改了一下，一切运行正常。过了几天你改了前一个位置的代码并调试至可以正常运行。之后，你在使用过程中发现后一个位置出了问题，你看了看发现原来是后面那里忘了改。</p>
</li>
<li><p>程序有bug，出问题的函数有一百多行，很难确定在哪个位置。</p>
<p>以上问题都在于过多功能杂糅到一个模块里，而没有把任务切块，分成若干个零件，单个模块承担了过多责任，即内聚性弱。或者一个地方的修改导致很多其他地方也要修改，即耦合性强。</p>
<p>如果要写归并排序，把二分和合并分开一定有助于编写；如果要写一个网页，若内容较多，将布局分成header、footer、aside、main，每一块单独做一个文件来处理会是不错的选择；使用vue开发，分割组件时，尽量用props暴露最低限度的接口而不是使用refs直接操作子组件（在必须耦合的情况下尽量数据耦合而不是控制耦合）；多个模块共享的数据应该是常量；一个模块只暴露必要的接口，其他部分应该对外部隐藏，而留出的接口应该在一开始就规划好以保证不到万不得已的情况不修改。</p>
<p>以上一些增强内聚性，降低耦合性的方法。</p>
<p><a href="https://baike.baidu.com/item/%E9%AB%98%E5%86%85%E8%81%9A%E4%BD%8E%E8%80%A6%E5%90%88/5227009?fr=aladdin">高内聚低耦合_百度百科</a></p>
</li>
</ul>
<h2 id="期望异构性"><a href="#期望异构性" class="headerlink" title="期望异构性"></a>期望异构性</h2><blockquote>
<p>在任何一个大型的网络中，可能存在不同类型的硬件、传输设施和应用程序。为了处理它们，网络的设计必须简单、通用和灵活。</p>
</blockquote>
<h2 id="避免静态选项和参数"><a href="#避免静态选项和参数" class="headerlink" title="避免静态选项和参数"></a>避免静态选项和参数</h2><blockquote>
<p>如果不可避免要使用参数的话（比如最大数据包长度)，那么，最好的办法是让发送方和接收方协商一个值，而不是定义固定的参数值。</p>
</blockquote>
<p>比如说设计网页时一个页面展示多少条信息可以由用户选择；设计mc的一个物品时它的掉落率可以由配置文件调整</p>
<h2 id="寻找好的而不是完美的设计"><a href="#寻找好的而不是完美的设计" class="headerlink" title="寻找好的而不是完美的设计"></a>寻找好的而不是完美的设计</h2><blockquote>
<p>通常设计者有一个好的设计，但是它不能够处理一些怪异的特殊情况。设计者不应该乱改设计，而是坚持这个好的设计，将围绕着特殊情况而展开的工作负担转移到那些强烈需求的人身上。</p>
</blockquote>
<h2 id="严格发送，宽容接收"><a href="#严格发送，宽容接收" class="headerlink" title="严格发送，宽容接收"></a>严格发送，宽容接收</h2><blockquote>
<p>换句话说，只发送那些严格符合标准的数据包，但是，容许接收那些不完全符合标准的数据包，并且试图对它们进行处理。</p>
</blockquote>
<p>分工设计时，不要想着别人的数据包是严格符合你的思维的，考虑好各种可能的null问题</p>
<h2 id="考虑可扩展性"><a href="#考虑可扩展性" class="headerlink" title="考虑可扩展性"></a>考虑可扩展性</h2><blockquote>
<p>如果系统需要有效地处理上百万台主机和几十亿用户，那么，没有一种中心数据库是可以容忍的,同时必须将负载尽可能均匀地分布到所有可用的资源上。</p>
</blockquote>
<h2 id="考虑性能和成本"><a href="#考虑性能和成本" class="headerlink" title="考虑性能和成本"></a>考虑性能和成本</h2><blockquote>
<p>如果一个网络的性能很差，或者成本很高，那么没有人会使用它。</p>
</blockquote>
]]></content>
      <categories>
        <category>规范与标准</category>
      </categories>
  </entry>
</search>
